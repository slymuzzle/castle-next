// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"journeyhub/ent"
	"journeyhub/ent/schema/pulid"
	"journeyhub/graph/model"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Device struct {
		CreatedAt func(childComplexity int) int
		DeviceID  func(childComplexity int) int
		FcmToken  func(childComplexity int) int
		ID        func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
	}

	DeviceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DeviceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	File struct {
		Bucket            func(childComplexity int) int
		ContentType       func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		ID                func(childComplexity int) int
		Location          func(childComplexity int) int
		MessageAttachment func(childComplexity int) int
		MessageVoice      func(childComplexity int) int
		Name              func(childComplexity int) int
		Path              func(childComplexity int) int
		Size              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	LastMessageUpdatedEvent struct {
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	LoginUser struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	Message struct {
		Attachments func(childComplexity int) int
		Content     func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Links       func(childComplexity int) int
		Replies     func(childComplexity int) int
		ReplyTo     func(childComplexity int) int
		Room        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		Voice       func(childComplexity int) int
	}

	MessageAttachment struct {
		AttachedAt func(childComplexity int) int
		File       func(childComplexity int) int
		ID         func(childComplexity int) int
		Message    func(childComplexity int) int
		Order      func(childComplexity int) int
		Room       func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	MessageAttachmentConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MessageAttachmentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	MessageConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MessageEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	MessageLink struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageURL    func(childComplexity int) int
		Link        func(childComplexity int) int
		Message     func(childComplexity int) int
		Room        func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	MessageLinkConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MessageLinkEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	MessageVoice struct {
		AttachedAt func(childComplexity int) int
		File       func(childComplexity int) int
		ID         func(childComplexity int) int
		Message    func(childComplexity int) int
		Room       func(childComplexity int) int
	}

	MessageVoiceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MessageVoiceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		AddUserContact        func(childComplexity int, pincode string) int
		CreateRoom            func(childComplexity int, input model.CreateRoomInput) int
		DeleteMessage         func(childComplexity int, messageID pulid.ID) int
		DeleteRoom            func(childComplexity int, roomID pulid.ID) int
		DeleteRoomMember      func(childComplexity int, roomMemberID pulid.ID) int
		DeleteUserContact     func(childComplexity int, userContactID pulid.ID) int
		GeneratePinCode       func(childComplexity int) int
		Login                 func(childComplexity int, input model.UserLoginInput) int
		MarkRoomMemeberAsSeen func(childComplexity int, roomMemberID pulid.ID) int
		Register              func(childComplexity int, input model.UserRegisterInput) int
		SendMessage           func(childComplexity int, input model.SendMessageInput) int
		UpdateMessage         func(childComplexity int, messageID pulid.ID, input model.UpdateMessageInput) int
		UpdateRoom            func(childComplexity int, roomID pulid.ID, input model.UpdateRoomInput) int
	}

	Notification struct {
		Body      func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		ID        func(childComplexity int) int
		Title     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
	}

	NotificationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	NotificationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		CallJoinToken            func(childComplexity int, roomID pulid.ID) int
		Devices                  func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.DeviceOrder, where *ent.DeviceWhereInput) int
		MessageAttachmentsByRoom func(childComplexity int, roomID pulid.ID, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageAttachmentOrder, where *ent.MessageAttachmentWhereInput) int
		MessageLinksByRoom       func(childComplexity int, roomID pulid.ID, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageLinkOrder, where *ent.MessageLinkWhereInput) int
		MessageVoicesByRoom      func(childComplexity int, roomID pulid.ID, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageVoiceOrder, where *ent.MessageVoiceWhereInput) int
		MessagesByRoom           func(childComplexity int, roomID pulid.ID, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Node                     func(childComplexity int, id pulid.ID) int
		Nodes                    func(childComplexity int, ids []pulid.ID) int
		Notifications            func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.NotificationOrder, where *ent.NotificationWhereInput) int
		Room                     func(childComplexity int, roomID pulid.ID) int
		RoomMembers              func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		RoomMembersByRoom        func(childComplexity int, roomID pulid.ID, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		Self                     func(childComplexity int) int
		UserContact              func(childComplexity int, userContactID pulid.ID) int
		UserContacts             func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserContactOrder, where *ent.UserContactWhereInput) int
	}

	Room struct {
		CreatedAt          func(childComplexity int) int
		Description        func(childComplexity int) int
		ID                 func(childComplexity int) int
		LastMessage        func(childComplexity int) int
		MessageAttachments func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageAttachmentOrder, where *ent.MessageAttachmentWhereInput) int
		MessageLinks       func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageLinkOrder, where *ent.MessageLinkWhereInput) int
		MessageVoices      func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageVoiceOrder, where *ent.MessageVoiceWhereInput) int
		Messages           func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Name               func(childComplexity int) int
		RoomMembers        func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		Type               func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		UserContacts       func(childComplexity int) int
		Users              func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		Version            func(childComplexity int) int
	}

	RoomConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RoomEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RoomMember struct {
		ID                  func(childComplexity int) int
		JoinedAt            func(childComplexity int) int
		Name                func(childComplexity int) int
		Room                func(childComplexity int) int
		RoomID              func(childComplexity int) int
		UnreadMessagesCount func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		User                func(childComplexity int) int
		UserID              func(childComplexity int) int
	}

	RoomMemberConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RoomMemberEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RoomMemberUpdatedEvent struct {
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		LastMessage func(childComplexity int) int
		Name        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	Subscription struct {
		MessageCreated    func(childComplexity int, roomID pulid.ID) int
		MessageDeleted    func(childComplexity int, roomID pulid.ID) int
		MessageUpdated    func(childComplexity int, roomID pulid.ID) int
		RoomMemberCreated func(childComplexity int) int
		RoomMemberDeleted func(childComplexity int) int
		RoomMemberUpdated func(childComplexity int) int
	}

	User struct {
		ContactPin    func(childComplexity int) int
		Contacts      func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		CreatedAt     func(childComplexity int) int
		Device        func(childComplexity int) int
		Email         func(childComplexity int) int
		FirstName     func(childComplexity int) int
		ID            func(childComplexity int) int
		LastName      func(childComplexity int) int
		Memberships   func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		Messages      func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Nickname      func(childComplexity int) int
		Notifications func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.NotificationOrder, where *ent.NotificationWhereInput) int
		Rooms         func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomOrder, where *ent.RoomWhereInput) int
		UpdatedAt     func(childComplexity int) int
		UserContacts  func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserContactOrder, where *ent.UserContactWhereInput) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserContact struct {
		Contact   func(childComplexity int) int
		ContactID func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Room      func(childComplexity int) int
		RoomID    func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	UserContactConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserContactEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Device.createdAt":
		if e.complexity.Device.CreatedAt == nil {
			break
		}

		return e.complexity.Device.CreatedAt(childComplexity), true

	case "Device.deviceID":
		if e.complexity.Device.DeviceID == nil {
			break
		}

		return e.complexity.Device.DeviceID(childComplexity), true

	case "Device.fcmToken":
		if e.complexity.Device.FcmToken == nil {
			break
		}

		return e.complexity.Device.FcmToken(childComplexity), true

	case "Device.id":
		if e.complexity.Device.ID == nil {
			break
		}

		return e.complexity.Device.ID(childComplexity), true

	case "Device.updatedAt":
		if e.complexity.Device.UpdatedAt == nil {
			break
		}

		return e.complexity.Device.UpdatedAt(childComplexity), true

	case "Device.user":
		if e.complexity.Device.User == nil {
			break
		}

		return e.complexity.Device.User(childComplexity), true

	case "DeviceConnection.edges":
		if e.complexity.DeviceConnection.Edges == nil {
			break
		}

		return e.complexity.DeviceConnection.Edges(childComplexity), true

	case "DeviceConnection.pageInfo":
		if e.complexity.DeviceConnection.PageInfo == nil {
			break
		}

		return e.complexity.DeviceConnection.PageInfo(childComplexity), true

	case "DeviceConnection.totalCount":
		if e.complexity.DeviceConnection.TotalCount == nil {
			break
		}

		return e.complexity.DeviceConnection.TotalCount(childComplexity), true

	case "DeviceEdge.cursor":
		if e.complexity.DeviceEdge.Cursor == nil {
			break
		}

		return e.complexity.DeviceEdge.Cursor(childComplexity), true

	case "DeviceEdge.node":
		if e.complexity.DeviceEdge.Node == nil {
			break
		}

		return e.complexity.DeviceEdge.Node(childComplexity), true

	case "File.bucket":
		if e.complexity.File.Bucket == nil {
			break
		}

		return e.complexity.File.Bucket(childComplexity), true

	case "File.contentType":
		if e.complexity.File.ContentType == nil {
			break
		}

		return e.complexity.File.ContentType(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.location":
		if e.complexity.File.Location == nil {
			break
		}

		return e.complexity.File.Location(childComplexity), true

	case "File.messageAttachment":
		if e.complexity.File.MessageAttachment == nil {
			break
		}

		return e.complexity.File.MessageAttachment(childComplexity), true

	case "File.messageVoice":
		if e.complexity.File.MessageVoice == nil {
			break
		}

		return e.complexity.File.MessageVoice(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.path":
		if e.complexity.File.Path == nil {
			break
		}

		return e.complexity.File.Path(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.updatedAt":
		if e.complexity.File.UpdatedAt == nil {
			break
		}

		return e.complexity.File.UpdatedAt(childComplexity), true

	case "LastMessageUpdatedEvent.content":
		if e.complexity.LastMessageUpdatedEvent.Content == nil {
			break
		}

		return e.complexity.LastMessageUpdatedEvent.Content(childComplexity), true

	case "LastMessageUpdatedEvent.createdAt":
		if e.complexity.LastMessageUpdatedEvent.CreatedAt == nil {
			break
		}

		return e.complexity.LastMessageUpdatedEvent.CreatedAt(childComplexity), true

	case "LastMessageUpdatedEvent.id":
		if e.complexity.LastMessageUpdatedEvent.ID == nil {
			break
		}

		return e.complexity.LastMessageUpdatedEvent.ID(childComplexity), true

	case "LastMessageUpdatedEvent.updatedAt":
		if e.complexity.LastMessageUpdatedEvent.UpdatedAt == nil {
			break
		}

		return e.complexity.LastMessageUpdatedEvent.UpdatedAt(childComplexity), true

	case "LoginUser.token":
		if e.complexity.LoginUser.Token == nil {
			break
		}

		return e.complexity.LoginUser.Token(childComplexity), true

	case "LoginUser.user":
		if e.complexity.LoginUser.User == nil {
			break
		}

		return e.complexity.LoginUser.User(childComplexity), true

	case "Message.attachments":
		if e.complexity.Message.Attachments == nil {
			break
		}

		return e.complexity.Message.Attachments(childComplexity), true

	case "Message.content":
		if e.complexity.Message.Content == nil {
			break
		}

		return e.complexity.Message.Content(childComplexity), true

	case "Message.createdAt":
		if e.complexity.Message.CreatedAt == nil {
			break
		}

		return e.complexity.Message.CreatedAt(childComplexity), true

	case "Message.id":
		if e.complexity.Message.ID == nil {
			break
		}

		return e.complexity.Message.ID(childComplexity), true

	case "Message.links":
		if e.complexity.Message.Links == nil {
			break
		}

		return e.complexity.Message.Links(childComplexity), true

	case "Message.replies":
		if e.complexity.Message.Replies == nil {
			break
		}

		return e.complexity.Message.Replies(childComplexity), true

	case "Message.replyTo":
		if e.complexity.Message.ReplyTo == nil {
			break
		}

		return e.complexity.Message.ReplyTo(childComplexity), true

	case "Message.room":
		if e.complexity.Message.Room == nil {
			break
		}

		return e.complexity.Message.Room(childComplexity), true

	case "Message.updatedAt":
		if e.complexity.Message.UpdatedAt == nil {
			break
		}

		return e.complexity.Message.UpdatedAt(childComplexity), true

	case "Message.user":
		if e.complexity.Message.User == nil {
			break
		}

		return e.complexity.Message.User(childComplexity), true

	case "Message.voice":
		if e.complexity.Message.Voice == nil {
			break
		}

		return e.complexity.Message.Voice(childComplexity), true

	case "MessageAttachment.attachedAt":
		if e.complexity.MessageAttachment.AttachedAt == nil {
			break
		}

		return e.complexity.MessageAttachment.AttachedAt(childComplexity), true

	case "MessageAttachment.file":
		if e.complexity.MessageAttachment.File == nil {
			break
		}

		return e.complexity.MessageAttachment.File(childComplexity), true

	case "MessageAttachment.id":
		if e.complexity.MessageAttachment.ID == nil {
			break
		}

		return e.complexity.MessageAttachment.ID(childComplexity), true

	case "MessageAttachment.message":
		if e.complexity.MessageAttachment.Message == nil {
			break
		}

		return e.complexity.MessageAttachment.Message(childComplexity), true

	case "MessageAttachment.order":
		if e.complexity.MessageAttachment.Order == nil {
			break
		}

		return e.complexity.MessageAttachment.Order(childComplexity), true

	case "MessageAttachment.room":
		if e.complexity.MessageAttachment.Room == nil {
			break
		}

		return e.complexity.MessageAttachment.Room(childComplexity), true

	case "MessageAttachment.type":
		if e.complexity.MessageAttachment.Type == nil {
			break
		}

		return e.complexity.MessageAttachment.Type(childComplexity), true

	case "MessageAttachmentConnection.edges":
		if e.complexity.MessageAttachmentConnection.Edges == nil {
			break
		}

		return e.complexity.MessageAttachmentConnection.Edges(childComplexity), true

	case "MessageAttachmentConnection.pageInfo":
		if e.complexity.MessageAttachmentConnection.PageInfo == nil {
			break
		}

		return e.complexity.MessageAttachmentConnection.PageInfo(childComplexity), true

	case "MessageAttachmentConnection.totalCount":
		if e.complexity.MessageAttachmentConnection.TotalCount == nil {
			break
		}

		return e.complexity.MessageAttachmentConnection.TotalCount(childComplexity), true

	case "MessageAttachmentEdge.cursor":
		if e.complexity.MessageAttachmentEdge.Cursor == nil {
			break
		}

		return e.complexity.MessageAttachmentEdge.Cursor(childComplexity), true

	case "MessageAttachmentEdge.node":
		if e.complexity.MessageAttachmentEdge.Node == nil {
			break
		}

		return e.complexity.MessageAttachmentEdge.Node(childComplexity), true

	case "MessageConnection.edges":
		if e.complexity.MessageConnection.Edges == nil {
			break
		}

		return e.complexity.MessageConnection.Edges(childComplexity), true

	case "MessageConnection.pageInfo":
		if e.complexity.MessageConnection.PageInfo == nil {
			break
		}

		return e.complexity.MessageConnection.PageInfo(childComplexity), true

	case "MessageConnection.totalCount":
		if e.complexity.MessageConnection.TotalCount == nil {
			break
		}

		return e.complexity.MessageConnection.TotalCount(childComplexity), true

	case "MessageEdge.cursor":
		if e.complexity.MessageEdge.Cursor == nil {
			break
		}

		return e.complexity.MessageEdge.Cursor(childComplexity), true

	case "MessageEdge.node":
		if e.complexity.MessageEdge.Node == nil {
			break
		}

		return e.complexity.MessageEdge.Node(childComplexity), true

	case "MessageLink.createdAt":
		if e.complexity.MessageLink.CreatedAt == nil {
			break
		}

		return e.complexity.MessageLink.CreatedAt(childComplexity), true

	case "MessageLink.description":
		if e.complexity.MessageLink.Description == nil {
			break
		}

		return e.complexity.MessageLink.Description(childComplexity), true

	case "MessageLink.id":
		if e.complexity.MessageLink.ID == nil {
			break
		}

		return e.complexity.MessageLink.ID(childComplexity), true

	case "MessageLink.imageURL":
		if e.complexity.MessageLink.ImageURL == nil {
			break
		}

		return e.complexity.MessageLink.ImageURL(childComplexity), true

	case "MessageLink.link":
		if e.complexity.MessageLink.Link == nil {
			break
		}

		return e.complexity.MessageLink.Link(childComplexity), true

	case "MessageLink.message":
		if e.complexity.MessageLink.Message == nil {
			break
		}

		return e.complexity.MessageLink.Message(childComplexity), true

	case "MessageLink.room":
		if e.complexity.MessageLink.Room == nil {
			break
		}

		return e.complexity.MessageLink.Room(childComplexity), true

	case "MessageLink.title":
		if e.complexity.MessageLink.Title == nil {
			break
		}

		return e.complexity.MessageLink.Title(childComplexity), true

	case "MessageLink.updatedAt":
		if e.complexity.MessageLink.UpdatedAt == nil {
			break
		}

		return e.complexity.MessageLink.UpdatedAt(childComplexity), true

	case "MessageLinkConnection.edges":
		if e.complexity.MessageLinkConnection.Edges == nil {
			break
		}

		return e.complexity.MessageLinkConnection.Edges(childComplexity), true

	case "MessageLinkConnection.pageInfo":
		if e.complexity.MessageLinkConnection.PageInfo == nil {
			break
		}

		return e.complexity.MessageLinkConnection.PageInfo(childComplexity), true

	case "MessageLinkConnection.totalCount":
		if e.complexity.MessageLinkConnection.TotalCount == nil {
			break
		}

		return e.complexity.MessageLinkConnection.TotalCount(childComplexity), true

	case "MessageLinkEdge.cursor":
		if e.complexity.MessageLinkEdge.Cursor == nil {
			break
		}

		return e.complexity.MessageLinkEdge.Cursor(childComplexity), true

	case "MessageLinkEdge.node":
		if e.complexity.MessageLinkEdge.Node == nil {
			break
		}

		return e.complexity.MessageLinkEdge.Node(childComplexity), true

	case "MessageVoice.attachedAt":
		if e.complexity.MessageVoice.AttachedAt == nil {
			break
		}

		return e.complexity.MessageVoice.AttachedAt(childComplexity), true

	case "MessageVoice.file":
		if e.complexity.MessageVoice.File == nil {
			break
		}

		return e.complexity.MessageVoice.File(childComplexity), true

	case "MessageVoice.id":
		if e.complexity.MessageVoice.ID == nil {
			break
		}

		return e.complexity.MessageVoice.ID(childComplexity), true

	case "MessageVoice.message":
		if e.complexity.MessageVoice.Message == nil {
			break
		}

		return e.complexity.MessageVoice.Message(childComplexity), true

	case "MessageVoice.room":
		if e.complexity.MessageVoice.Room == nil {
			break
		}

		return e.complexity.MessageVoice.Room(childComplexity), true

	case "MessageVoiceConnection.edges":
		if e.complexity.MessageVoiceConnection.Edges == nil {
			break
		}

		return e.complexity.MessageVoiceConnection.Edges(childComplexity), true

	case "MessageVoiceConnection.pageInfo":
		if e.complexity.MessageVoiceConnection.PageInfo == nil {
			break
		}

		return e.complexity.MessageVoiceConnection.PageInfo(childComplexity), true

	case "MessageVoiceConnection.totalCount":
		if e.complexity.MessageVoiceConnection.TotalCount == nil {
			break
		}

		return e.complexity.MessageVoiceConnection.TotalCount(childComplexity), true

	case "MessageVoiceEdge.cursor":
		if e.complexity.MessageVoiceEdge.Cursor == nil {
			break
		}

		return e.complexity.MessageVoiceEdge.Cursor(childComplexity), true

	case "MessageVoiceEdge.node":
		if e.complexity.MessageVoiceEdge.Node == nil {
			break
		}

		return e.complexity.MessageVoiceEdge.Node(childComplexity), true

	case "Mutation.addUserContact":
		if e.complexity.Mutation.AddUserContact == nil {
			break
		}

		args, err := ec.field_Mutation_addUserContact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserContact(childComplexity, args["pincode"].(string)), true

	case "Mutation.createRoom":
		if e.complexity.Mutation.CreateRoom == nil {
			break
		}

		args, err := ec.field_Mutation_createRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRoom(childComplexity, args["input"].(model.CreateRoomInput)), true

	case "Mutation.deleteMessage":
		if e.complexity.Mutation.DeleteMessage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMessage(childComplexity, args["messageID"].(pulid.ID)), true

	case "Mutation.deleteRoom":
		if e.complexity.Mutation.DeleteRoom == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRoom(childComplexity, args["roomID"].(pulid.ID)), true

	case "Mutation.deleteRoomMember":
		if e.complexity.Mutation.DeleteRoomMember == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRoomMember_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRoomMember(childComplexity, args["roomMemberID"].(pulid.ID)), true

	case "Mutation.deleteUserContact":
		if e.complexity.Mutation.DeleteUserContact == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserContact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserContact(childComplexity, args["userContactID"].(pulid.ID)), true

	case "Mutation.generatePinCode":
		if e.complexity.Mutation.GeneratePinCode == nil {
			break
		}

		return e.complexity.Mutation.GeneratePinCode(childComplexity), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.UserLoginInput)), true

	case "Mutation.markRoomMemeberAsSeen":
		if e.complexity.Mutation.MarkRoomMemeberAsSeen == nil {
			break
		}

		args, err := ec.field_Mutation_markRoomMemeberAsSeen_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarkRoomMemeberAsSeen(childComplexity, args["roomMemberID"].(pulid.ID)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["input"].(model.UserRegisterInput)), true

	case "Mutation.sendMessage":
		if e.complexity.Mutation.SendMessage == nil {
			break
		}

		args, err := ec.field_Mutation_sendMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendMessage(childComplexity, args["input"].(model.SendMessageInput)), true

	case "Mutation.updateMessage":
		if e.complexity.Mutation.UpdateMessage == nil {
			break
		}

		args, err := ec.field_Mutation_updateMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMessage(childComplexity, args["messageID"].(pulid.ID), args["input"].(model.UpdateMessageInput)), true

	case "Mutation.updateRoom":
		if e.complexity.Mutation.UpdateRoom == nil {
			break
		}

		args, err := ec.field_Mutation_updateRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRoom(childComplexity, args["roomID"].(pulid.ID), args["input"].(model.UpdateRoomInput)), true

	case "Notification.body":
		if e.complexity.Notification.Body == nil {
			break
		}

		return e.complexity.Notification.Body(childComplexity), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.data":
		if e.complexity.Notification.Data == nil {
			break
		}

		return e.complexity.Notification.Data(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.title":
		if e.complexity.Notification.Title == nil {
			break
		}

		return e.complexity.Notification.Title(childComplexity), true

	case "Notification.updatedAt":
		if e.complexity.Notification.UpdatedAt == nil {
			break
		}

		return e.complexity.Notification.UpdatedAt(childComplexity), true

	case "Notification.user":
		if e.complexity.Notification.User == nil {
			break
		}

		return e.complexity.Notification.User(childComplexity), true

	case "NotificationConnection.edges":
		if e.complexity.NotificationConnection.Edges == nil {
			break
		}

		return e.complexity.NotificationConnection.Edges(childComplexity), true

	case "NotificationConnection.pageInfo":
		if e.complexity.NotificationConnection.PageInfo == nil {
			break
		}

		return e.complexity.NotificationConnection.PageInfo(childComplexity), true

	case "NotificationConnection.totalCount":
		if e.complexity.NotificationConnection.TotalCount == nil {
			break
		}

		return e.complexity.NotificationConnection.TotalCount(childComplexity), true

	case "NotificationEdge.cursor":
		if e.complexity.NotificationEdge.Cursor == nil {
			break
		}

		return e.complexity.NotificationEdge.Cursor(childComplexity), true

	case "NotificationEdge.node":
		if e.complexity.NotificationEdge.Node == nil {
			break
		}

		return e.complexity.NotificationEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.callJoinToken":
		if e.complexity.Query.CallJoinToken == nil {
			break
		}

		args, err := ec.field_Query_callJoinToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CallJoinToken(childComplexity, args["roomID"].(pulid.ID)), true

	case "Query.devices":
		if e.complexity.Query.Devices == nil {
			break
		}

		args, err := ec.field_Query_devices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Devices(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.DeviceOrder), args["where"].(*ent.DeviceWhereInput)), true

	case "Query.messageAttachmentsByRoom":
		if e.complexity.Query.MessageAttachmentsByRoom == nil {
			break
		}

		args, err := ec.field_Query_messageAttachmentsByRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageAttachmentsByRoom(childComplexity, args["roomID"].(pulid.ID), args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageAttachmentOrder), args["where"].(*ent.MessageAttachmentWhereInput)), true

	case "Query.messageLinksByRoom":
		if e.complexity.Query.MessageLinksByRoom == nil {
			break
		}

		args, err := ec.field_Query_messageLinksByRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageLinksByRoom(childComplexity, args["roomID"].(pulid.ID), args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageLinkOrder), args["where"].(*ent.MessageLinkWhereInput)), true

	case "Query.messageVoicesByRoom":
		if e.complexity.Query.MessageVoicesByRoom == nil {
			break
		}

		args, err := ec.field_Query_messageVoicesByRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageVoicesByRoom(childComplexity, args["roomID"].(pulid.ID), args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageVoiceOrder), args["where"].(*ent.MessageVoiceWhereInput)), true

	case "Query.messagesByRoom":
		if e.complexity.Query.MessagesByRoom == nil {
			break
		}

		args, err := ec.field_Query_messagesByRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessagesByRoom(childComplexity, args["roomID"].(pulid.ID), args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(pulid.ID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]pulid.ID)), true

	case "Query.notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		args, err := ec.field_Query_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Notifications(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.NotificationOrder), args["where"].(*ent.NotificationWhereInput)), true

	case "Query.room":
		if e.complexity.Query.Room == nil {
			break
		}

		args, err := ec.field_Query_room_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Room(childComplexity, args["roomID"].(pulid.ID)), true

	case "Query.roomMembers":
		if e.complexity.Query.RoomMembers == nil {
			break
		}

		args, err := ec.field_Query_roomMembers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RoomMembers(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "Query.roomMembersByRoom":
		if e.complexity.Query.RoomMembersByRoom == nil {
			break
		}

		args, err := ec.field_Query_roomMembersByRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RoomMembersByRoom(childComplexity, args["roomID"].(pulid.ID), args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "Query.self":
		if e.complexity.Query.Self == nil {
			break
		}

		return e.complexity.Query.Self(childComplexity), true

	case "Query.userContact":
		if e.complexity.Query.UserContact == nil {
			break
		}

		args, err := ec.field_Query_userContact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserContact(childComplexity, args["userContactID"].(pulid.ID)), true

	case "Query.userContacts":
		if e.complexity.Query.UserContacts == nil {
			break
		}

		args, err := ec.field_Query_userContacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserContacts(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserContactOrder), args["where"].(*ent.UserContactWhereInput)), true

	case "Room.createdAt":
		if e.complexity.Room.CreatedAt == nil {
			break
		}

		return e.complexity.Room.CreatedAt(childComplexity), true

	case "Room.description":
		if e.complexity.Room.Description == nil {
			break
		}

		return e.complexity.Room.Description(childComplexity), true

	case "Room.id":
		if e.complexity.Room.ID == nil {
			break
		}

		return e.complexity.Room.ID(childComplexity), true

	case "Room.lastMessage":
		if e.complexity.Room.LastMessage == nil {
			break
		}

		return e.complexity.Room.LastMessage(childComplexity), true

	case "Room.messageAttachments":
		if e.complexity.Room.MessageAttachments == nil {
			break
		}

		args, err := ec.field_Room_messageAttachments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.MessageAttachments(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageAttachmentOrder), args["where"].(*ent.MessageAttachmentWhereInput)), true

	case "Room.messageLinks":
		if e.complexity.Room.MessageLinks == nil {
			break
		}

		args, err := ec.field_Room_messageLinks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.MessageLinks(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageLinkOrder), args["where"].(*ent.MessageLinkWhereInput)), true

	case "Room.messageVoices":
		if e.complexity.Room.MessageVoices == nil {
			break
		}

		args, err := ec.field_Room_messageVoices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.MessageVoices(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageVoiceOrder), args["where"].(*ent.MessageVoiceWhereInput)), true

	case "Room.messages":
		if e.complexity.Room.Messages == nil {
			break
		}

		args, err := ec.field_Room_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "Room.name":
		if e.complexity.Room.Name == nil {
			break
		}

		return e.complexity.Room.Name(childComplexity), true

	case "Room.roomMembers":
		if e.complexity.Room.RoomMembers == nil {
			break
		}

		args, err := ec.field_Room_roomMembers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.RoomMembers(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "Room.type":
		if e.complexity.Room.Type == nil {
			break
		}

		return e.complexity.Room.Type(childComplexity), true

	case "Room.updatedAt":
		if e.complexity.Room.UpdatedAt == nil {
			break
		}

		return e.complexity.Room.UpdatedAt(childComplexity), true

	case "Room.userContacts":
		if e.complexity.Room.UserContacts == nil {
			break
		}

		return e.complexity.Room.UserContacts(childComplexity), true

	case "Room.users":
		if e.complexity.Room.Users == nil {
			break
		}

		args, err := ec.field_Room_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.Users(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Room.version":
		if e.complexity.Room.Version == nil {
			break
		}

		return e.complexity.Room.Version(childComplexity), true

	case "RoomConnection.edges":
		if e.complexity.RoomConnection.Edges == nil {
			break
		}

		return e.complexity.RoomConnection.Edges(childComplexity), true

	case "RoomConnection.pageInfo":
		if e.complexity.RoomConnection.PageInfo == nil {
			break
		}

		return e.complexity.RoomConnection.PageInfo(childComplexity), true

	case "RoomConnection.totalCount":
		if e.complexity.RoomConnection.TotalCount == nil {
			break
		}

		return e.complexity.RoomConnection.TotalCount(childComplexity), true

	case "RoomEdge.cursor":
		if e.complexity.RoomEdge.Cursor == nil {
			break
		}

		return e.complexity.RoomEdge.Cursor(childComplexity), true

	case "RoomEdge.node":
		if e.complexity.RoomEdge.Node == nil {
			break
		}

		return e.complexity.RoomEdge.Node(childComplexity), true

	case "RoomMember.id":
		if e.complexity.RoomMember.ID == nil {
			break
		}

		return e.complexity.RoomMember.ID(childComplexity), true

	case "RoomMember.joinedAt":
		if e.complexity.RoomMember.JoinedAt == nil {
			break
		}

		return e.complexity.RoomMember.JoinedAt(childComplexity), true

	case "RoomMember.name":
		if e.complexity.RoomMember.Name == nil {
			break
		}

		return e.complexity.RoomMember.Name(childComplexity), true

	case "RoomMember.room":
		if e.complexity.RoomMember.Room == nil {
			break
		}

		return e.complexity.RoomMember.Room(childComplexity), true

	case "RoomMember.roomID":
		if e.complexity.RoomMember.RoomID == nil {
			break
		}

		return e.complexity.RoomMember.RoomID(childComplexity), true

	case "RoomMember.unreadMessagesCount":
		if e.complexity.RoomMember.UnreadMessagesCount == nil {
			break
		}

		return e.complexity.RoomMember.UnreadMessagesCount(childComplexity), true

	case "RoomMember.updatedAt":
		if e.complexity.RoomMember.UpdatedAt == nil {
			break
		}

		return e.complexity.RoomMember.UpdatedAt(childComplexity), true

	case "RoomMember.user":
		if e.complexity.RoomMember.User == nil {
			break
		}

		return e.complexity.RoomMember.User(childComplexity), true

	case "RoomMember.userID":
		if e.complexity.RoomMember.UserID == nil {
			break
		}

		return e.complexity.RoomMember.UserID(childComplexity), true

	case "RoomMemberConnection.edges":
		if e.complexity.RoomMemberConnection.Edges == nil {
			break
		}

		return e.complexity.RoomMemberConnection.Edges(childComplexity), true

	case "RoomMemberConnection.pageInfo":
		if e.complexity.RoomMemberConnection.PageInfo == nil {
			break
		}

		return e.complexity.RoomMemberConnection.PageInfo(childComplexity), true

	case "RoomMemberConnection.totalCount":
		if e.complexity.RoomMemberConnection.TotalCount == nil {
			break
		}

		return e.complexity.RoomMemberConnection.TotalCount(childComplexity), true

	case "RoomMemberEdge.cursor":
		if e.complexity.RoomMemberEdge.Cursor == nil {
			break
		}

		return e.complexity.RoomMemberEdge.Cursor(childComplexity), true

	case "RoomMemberEdge.node":
		if e.complexity.RoomMemberEdge.Node == nil {
			break
		}

		return e.complexity.RoomMemberEdge.Node(childComplexity), true

	case "RoomMemberUpdatedEvent.createdAt":
		if e.complexity.RoomMemberUpdatedEvent.CreatedAt == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.CreatedAt(childComplexity), true

	case "RoomMemberUpdatedEvent.id":
		if e.complexity.RoomMemberUpdatedEvent.ID == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.ID(childComplexity), true

	case "RoomMemberUpdatedEvent.lastMessage":
		if e.complexity.RoomMemberUpdatedEvent.LastMessage == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.LastMessage(childComplexity), true

	case "RoomMemberUpdatedEvent.name":
		if e.complexity.RoomMemberUpdatedEvent.Name == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.Name(childComplexity), true

	case "RoomMemberUpdatedEvent.type":
		if e.complexity.RoomMemberUpdatedEvent.Type == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.Type(childComplexity), true

	case "RoomMemberUpdatedEvent.updatedAt":
		if e.complexity.RoomMemberUpdatedEvent.UpdatedAt == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.UpdatedAt(childComplexity), true

	case "RoomMemberUpdatedEvent.version":
		if e.complexity.RoomMemberUpdatedEvent.Version == nil {
			break
		}

		return e.complexity.RoomMemberUpdatedEvent.Version(childComplexity), true

	case "Subscription.messageCreated":
		if e.complexity.Subscription.MessageCreated == nil {
			break
		}

		args, err := ec.field_Subscription_messageCreated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.MessageCreated(childComplexity, args["roomID"].(pulid.ID)), true

	case "Subscription.messageDeleted":
		if e.complexity.Subscription.MessageDeleted == nil {
			break
		}

		args, err := ec.field_Subscription_messageDeleted_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.MessageDeleted(childComplexity, args["roomID"].(pulid.ID)), true

	case "Subscription.messageUpdated":
		if e.complexity.Subscription.MessageUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_messageUpdated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.MessageUpdated(childComplexity, args["roomID"].(pulid.ID)), true

	case "Subscription.roomMemberCreated":
		if e.complexity.Subscription.RoomMemberCreated == nil {
			break
		}

		return e.complexity.Subscription.RoomMemberCreated(childComplexity), true

	case "Subscription.roomMemberDeleted":
		if e.complexity.Subscription.RoomMemberDeleted == nil {
			break
		}

		return e.complexity.Subscription.RoomMemberDeleted(childComplexity), true

	case "Subscription.roomMemberUpdated":
		if e.complexity.Subscription.RoomMemberUpdated == nil {
			break
		}

		return e.complexity.Subscription.RoomMemberUpdated(childComplexity), true

	case "User.contactPin":
		if e.complexity.User.ContactPin == nil {
			break
		}

		return e.complexity.User.ContactPin(childComplexity), true

	case "User.contacts":
		if e.complexity.User.Contacts == nil {
			break
		}

		args, err := ec.field_User_contacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Contacts(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.device":
		if e.complexity.User.Device == nil {
			break
		}

		return e.complexity.User.Device(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.firstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.memberships":
		if e.complexity.User.Memberships == nil {
			break
		}

		args, err := ec.field_User_memberships_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Memberships(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "User.messages":
		if e.complexity.User.Messages == nil {
			break
		}

		args, err := ec.field_User_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "User.nickname":
		if e.complexity.User.Nickname == nil {
			break
		}

		return e.complexity.User.Nickname(childComplexity), true

	case "User.notifications":
		if e.complexity.User.Notifications == nil {
			break
		}

		args, err := ec.field_User_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Notifications(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.NotificationOrder), args["where"].(*ent.NotificationWhereInput)), true

	case "User.rooms":
		if e.complexity.User.Rooms == nil {
			break
		}

		args, err := ec.field_User_rooms_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Rooms(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomOrder), args["where"].(*ent.RoomWhereInput)), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.userContacts":
		if e.complexity.User.UserContacts == nil {
			break
		}

		args, err := ec.field_User_userContacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.UserContacts(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserContactOrder), args["where"].(*ent.UserContactWhereInput)), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserContact.contact":
		if e.complexity.UserContact.Contact == nil {
			break
		}

		return e.complexity.UserContact.Contact(childComplexity), true

	case "UserContact.contactID":
		if e.complexity.UserContact.ContactID == nil {
			break
		}

		return e.complexity.UserContact.ContactID(childComplexity), true

	case "UserContact.createdAt":
		if e.complexity.UserContact.CreatedAt == nil {
			break
		}

		return e.complexity.UserContact.CreatedAt(childComplexity), true

	case "UserContact.id":
		if e.complexity.UserContact.ID == nil {
			break
		}

		return e.complexity.UserContact.ID(childComplexity), true

	case "UserContact.room":
		if e.complexity.UserContact.Room == nil {
			break
		}

		return e.complexity.UserContact.Room(childComplexity), true

	case "UserContact.roomID":
		if e.complexity.UserContact.RoomID == nil {
			break
		}

		return e.complexity.UserContact.RoomID(childComplexity), true

	case "UserContact.user":
		if e.complexity.UserContact.User == nil {
			break
		}

		return e.complexity.UserContact.User(childComplexity), true

	case "UserContact.userID":
		if e.complexity.UserContact.UserID == nil {
			break
		}

		return e.complexity.UserContact.UserID(childComplexity), true

	case "UserContactConnection.edges":
		if e.complexity.UserContactConnection.Edges == nil {
			break
		}

		return e.complexity.UserContactConnection.Edges(childComplexity), true

	case "UserContactConnection.pageInfo":
		if e.complexity.UserContactConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserContactConnection.PageInfo(childComplexity), true

	case "UserContactConnection.totalCount":
		if e.complexity.UserContactConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserContactConnection.TotalCount(childComplexity), true

	case "UserContactEdge.cursor":
		if e.complexity.UserContactEdge.Cursor == nil {
			break
		}

		return e.complexity.UserContactEdge.Cursor(childComplexity), true

	case "UserContactEdge.node":
		if e.complexity.UserContactEdge.Node == nil {
			break
		}

		return e.complexity.UserContactEdge.Node(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateMessageLinkInput,
		ec.unmarshalInputCreateRoomInput,
		ec.unmarshalInputDeviceOrder,
		ec.unmarshalInputDeviceWhereInput,
		ec.unmarshalInputFileOrder,
		ec.unmarshalInputFileWhereInput,
		ec.unmarshalInputMessageAttachmentOrder,
		ec.unmarshalInputMessageAttachmentWhereInput,
		ec.unmarshalInputMessageLinkOrder,
		ec.unmarshalInputMessageLinkWhereInput,
		ec.unmarshalInputMessageOrder,
		ec.unmarshalInputMessageVoiceOrder,
		ec.unmarshalInputMessageVoiceWhereInput,
		ec.unmarshalInputMessageWhereInput,
		ec.unmarshalInputNotificationOrder,
		ec.unmarshalInputNotificationWhereInput,
		ec.unmarshalInputRoomMemberOrder,
		ec.unmarshalInputRoomMemberWhereInput,
		ec.unmarshalInputRoomOrder,
		ec.unmarshalInputRoomWhereInput,
		ec.unmarshalInputSendMessageInput,
		ec.unmarshalInputUpdateMessageInput,
		ec.unmarshalInputUpdateRoomInput,
		ec.unmarshalInputUploadMessageFileInput,
		ec.unmarshalInputUserContactOrder,
		ec.unmarshalInputUserContactWhereInput,
		ec.unmarshalInputUserLoginInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserRegisterInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/call.graphql", Input: `extend type Query {
  callJoinToken(roomID: ID!): String!
}
`, BuiltIn: false},
	{Name: "../schema/directives.graphql", Input: `directive @goTag(
  key: String!
  value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Device implements Node {
  id: ID!
  deviceID: String!
  fcmToken: String!
  createdAt: Time!
  updatedAt: Time!
  user: User!
}
"""
A connection to a list of items.
"""
type DeviceConnection {
  """
  A list of edges.
  """
  edges: [DeviceEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type DeviceEdge {
  """
  The item at the end of the edge.
  """
  node: Device
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Device connections
"""
input DeviceOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Devices.
  """
  field: DeviceOrderField!
}
"""
Properties by which Device connections can be ordered.
"""
enum DeviceOrderField {
  DEVICE_ID
  FCM_TOKEN
  CREATED_AT
  UPDATED_AT
}
"""
DeviceWhereInput is used for filtering Device objects.
Input was generated by ent.
"""
input DeviceWhereInput {
  not: DeviceWhereInput
  and: [DeviceWhereInput!]
  or: [DeviceWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  device_id field predicates
  """
  deviceID: String
  deviceIDNEQ: String
  deviceIDIn: [String!]
  deviceIDNotIn: [String!]
  deviceIDGT: String
  deviceIDGTE: String
  deviceIDLT: String
  deviceIDLTE: String
  deviceIDContains: String
  deviceIDHasPrefix: String
  deviceIDHasSuffix: String
  deviceIDEqualFold: String
  deviceIDContainsFold: String
  """
  fcm_token field predicates
  """
  fcmToken: String
  fcmTokenNEQ: String
  fcmTokenIn: [String!]
  fcmTokenNotIn: [String!]
  fcmTokenGT: String
  fcmTokenGTE: String
  fcmTokenLT: String
  fcmTokenLTE: String
  fcmTokenContains: String
  fcmTokenHasPrefix: String
  fcmTokenHasSuffix: String
  fcmTokenEqualFold: String
  fcmTokenContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
}
type File implements Node {
  id: ID!
  name: String!
  contentType: String!
  size: Uint64!
  location: String
  bucket: String!
  path: String!
  createdAt: Time!
  updatedAt: Time!
  messageAttachment: MessageAttachment
  messageVoice: MessageVoice
}
"""
Ordering options for File connections
"""
input FileOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Files.
  """
  field: FileOrderField!
}
"""
Properties by which File connections can be ordered.
"""
enum FileOrderField {
  NAME
  CONTENT_TYPE
  SIZE
  LOCATION
  BUCKET
  PATH
  CREATED_AT
  UPDATED_AT
}
"""
FileWhereInput is used for filtering File objects.
Input was generated by ent.
"""
input FileWhereInput {
  not: FileWhereInput
  and: [FileWhereInput!]
  or: [FileWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  content_type field predicates
  """
  contentType: String
  contentTypeNEQ: String
  contentTypeIn: [String!]
  contentTypeNotIn: [String!]
  contentTypeGT: String
  contentTypeGTE: String
  contentTypeLT: String
  contentTypeLTE: String
  contentTypeContains: String
  contentTypeHasPrefix: String
  contentTypeHasSuffix: String
  contentTypeEqualFold: String
  contentTypeContainsFold: String
  """
  size field predicates
  """
  size: Uint64
  sizeNEQ: Uint64
  sizeIn: [Uint64!]
  sizeNotIn: [Uint64!]
  sizeGT: Uint64
  sizeGTE: Uint64
  sizeLT: Uint64
  sizeLTE: Uint64
  """
  location field predicates
  """
  location: String
  locationNEQ: String
  locationIn: [String!]
  locationNotIn: [String!]
  locationGT: String
  locationGTE: String
  locationLT: String
  locationLTE: String
  locationContains: String
  locationHasPrefix: String
  locationHasSuffix: String
  locationIsNil: Boolean
  locationNotNil: Boolean
  locationEqualFold: String
  locationContainsFold: String
  """
  bucket field predicates
  """
  bucket: String
  bucketNEQ: String
  bucketIn: [String!]
  bucketNotIn: [String!]
  bucketGT: String
  bucketGTE: String
  bucketLT: String
  bucketLTE: String
  bucketContains: String
  bucketHasPrefix: String
  bucketHasSuffix: String
  bucketEqualFold: String
  bucketContainsFold: String
  """
  path field predicates
  """
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  message_attachment edge predicates
  """
  hasMessageAttachment: Boolean
  hasMessageAttachmentWith: [MessageAttachmentWhereInput!]
  """
  message_voice edge predicates
  """
  hasMessageVoice: Boolean
  hasMessageVoiceWith: [MessageVoiceWhereInput!]
}
"""
The builtin Map type
"""
scalar Map
type Message implements Node {
  id: ID!
  content: String
  createdAt: Time!
  updatedAt: Time!
  voice: MessageVoice
  replyTo: Message
  replies: [Message!]
  attachments: [MessageAttachment!]
  links: [MessageLink!]
  user: User
  room: Room
}
type MessageAttachment implements Node {
  id: ID!
  type: MessageAttachmentType!
  order: Uint!
  attachedAt: Time!
  room: Room!
  message: Message!
  file: File!
}
"""
A connection to a list of items.
"""
type MessageAttachmentConnection {
  """
  A list of edges.
  """
  edges: [MessageAttachmentEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type MessageAttachmentEdge {
  """
  The item at the end of the edge.
  """
  node: MessageAttachment
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for MessageAttachment connections
"""
input MessageAttachmentOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order MessageAttachments.
  """
  field: MessageAttachmentOrderField!
}
"""
Properties by which MessageAttachment connections can be ordered.
"""
enum MessageAttachmentOrderField {
  TYPE
  ORDER
  ATTACHED_AT
}
"""
MessageAttachmentType is enum for the field type
"""
enum MessageAttachmentType @goModel(model: "journeyhub/ent/messageattachment.Type") {
  Media
  File
}
"""
MessageAttachmentWhereInput is used for filtering MessageAttachment objects.
Input was generated by ent.
"""
input MessageAttachmentWhereInput {
  not: MessageAttachmentWhereInput
  and: [MessageAttachmentWhereInput!]
  or: [MessageAttachmentWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  type field predicates
  """
  type: MessageAttachmentType
  typeNEQ: MessageAttachmentType
  typeIn: [MessageAttachmentType!]
  typeNotIn: [MessageAttachmentType!]
  """
  order field predicates
  """
  order: Uint
  orderNEQ: Uint
  orderIn: [Uint!]
  orderNotIn: [Uint!]
  orderGT: Uint
  orderGTE: Uint
  orderLT: Uint
  orderLTE: Uint
  """
  attached_at field predicates
  """
  attachedAt: Time
  attachedAtNEQ: Time
  attachedAtIn: [Time!]
  attachedAtNotIn: [Time!]
  attachedAtGT: Time
  attachedAtGTE: Time
  attachedAtLT: Time
  attachedAtLTE: Time
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
  """
  file edge predicates
  """
  hasFile: Boolean
  hasFileWith: [FileWhereInput!]
}
"""
A connection to a list of items.
"""
type MessageConnection {
  """
  A list of edges.
  """
  edges: [MessageEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type MessageEdge {
  """
  The item at the end of the edge.
  """
  node: Message
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type MessageLink implements Node {
  id: ID!
  link: String!
  title: String
  description: String
  imageURL: String
  createdAt: Time!
  updatedAt: Time!
  room: Room!
  message: Message!
}
"""
A connection to a list of items.
"""
type MessageLinkConnection {
  """
  A list of edges.
  """
  edges: [MessageLinkEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type MessageLinkEdge {
  """
  The item at the end of the edge.
  """
  node: MessageLink
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for MessageLink connections
"""
input MessageLinkOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order MessageLinks.
  """
  field: MessageLinkOrderField!
}
"""
Properties by which MessageLink connections can be ordered.
"""
enum MessageLinkOrderField {
  LINK
  TITLE
  DESCRIPTION
  IMAGE_URL
  CREATED_AT
  UPDATED_AT
}
"""
MessageLinkWhereInput is used for filtering MessageLink objects.
Input was generated by ent.
"""
input MessageLinkWhereInput {
  not: MessageLinkWhereInput
  and: [MessageLinkWhereInput!]
  or: [MessageLinkWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  link field predicates
  """
  link: String
  linkNEQ: String
  linkIn: [String!]
  linkNotIn: [String!]
  linkGT: String
  linkGTE: String
  linkLT: String
  linkLTE: String
  linkContains: String
  linkHasPrefix: String
  linkHasSuffix: String
  linkEqualFold: String
  linkContainsFold: String
  """
  title field predicates
  """
  title: String
  titleNEQ: String
  titleIn: [String!]
  titleNotIn: [String!]
  titleGT: String
  titleGTE: String
  titleLT: String
  titleLTE: String
  titleContains: String
  titleHasPrefix: String
  titleHasSuffix: String
  titleIsNil: Boolean
  titleNotNil: Boolean
  titleEqualFold: String
  titleContainsFold: String
  """
  description field predicates
  """
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """
  image_url field predicates
  """
  imageURL: String
  imageURLNEQ: String
  imageURLIn: [String!]
  imageURLNotIn: [String!]
  imageURLGT: String
  imageURLGTE: String
  imageURLLT: String
  imageURLLTE: String
  imageURLContains: String
  imageURLHasPrefix: String
  imageURLHasSuffix: String
  imageURLIsNil: Boolean
  imageURLNotNil: Boolean
  imageURLEqualFold: String
  imageURLContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
}
"""
Ordering options for Message connections
"""
input MessageOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Messages.
  """
  field: MessageOrderField!
}
"""
Properties by which Message connections can be ordered.
"""
enum MessageOrderField {
  CREATED_AT
  UPDATED_AT
}
type MessageVoice implements Node {
  id: ID!
  attachedAt: Time!
  room: Room!
  message: Message!
  file: File!
}
"""
A connection to a list of items.
"""
type MessageVoiceConnection {
  """
  A list of edges.
  """
  edges: [MessageVoiceEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type MessageVoiceEdge {
  """
  The item at the end of the edge.
  """
  node: MessageVoice
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for MessageVoice connections
"""
input MessageVoiceOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order MessageVoices.
  """
  field: MessageVoiceOrderField!
}
"""
Properties by which MessageVoice connections can be ordered.
"""
enum MessageVoiceOrderField {
  ATTACHED_AT
}
"""
MessageVoiceWhereInput is used for filtering MessageVoice objects.
Input was generated by ent.
"""
input MessageVoiceWhereInput {
  not: MessageVoiceWhereInput
  and: [MessageVoiceWhereInput!]
  or: [MessageVoiceWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  attached_at field predicates
  """
  attachedAt: Time
  attachedAtNEQ: Time
  attachedAtIn: [Time!]
  attachedAtNotIn: [Time!]
  attachedAtGT: Time
  attachedAtGTE: Time
  attachedAtLT: Time
  attachedAtLTE: Time
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
  """
  file edge predicates
  """
  hasFile: Boolean
  hasFileWith: [FileWhereInput!]
}
"""
MessageWhereInput is used for filtering Message objects.
Input was generated by ent.
"""
input MessageWhereInput {
  not: MessageWhereInput
  and: [MessageWhereInput!]
  or: [MessageWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  content field predicates
  """
  content: String
  contentNEQ: String
  contentIn: [String!]
  contentNotIn: [String!]
  contentGT: String
  contentGTE: String
  contentLT: String
  contentLTE: String
  contentContains: String
  contentHasPrefix: String
  contentHasSuffix: String
  contentIsNil: Boolean
  contentNotNil: Boolean
  contentEqualFold: String
  contentContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  voice edge predicates
  """
  hasVoice: Boolean
  hasVoiceWith: [MessageVoiceWhereInput!]
  """
  reply_to edge predicates
  """
  hasReplyTo: Boolean
  hasReplyToWith: [MessageWhereInput!]
  """
  replies edge predicates
  """
  hasReplies: Boolean
  hasRepliesWith: [MessageWhereInput!]
  """
  attachments edge predicates
  """
  hasAttachments: Boolean
  hasAttachmentsWith: [MessageAttachmentWhereInput!]
  """
  links edge predicates
  """
  hasLinks: Boolean
  hasLinksWith: [MessageLinkWhereInput!]
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "journeyhub/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
type Notification implements Node {
  id: ID!
  title: String!
  body: String!
  data: Map
  createdAt: Time!
  updatedAt: Time!
  user: User
}
"""
A connection to a list of items.
"""
type NotificationConnection {
  """
  A list of edges.
  """
  edges: [NotificationEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type NotificationEdge {
  """
  The item at the end of the edge.
  """
  node: Notification
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Notification connections
"""
input NotificationOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Notifications.
  """
  field: NotificationOrderField!
}
"""
Properties by which Notification connections can be ordered.
"""
enum NotificationOrderField {
  TITLE
  CREATED_AT
  UPDATED_AT
}
"""
NotificationWhereInput is used for filtering Notification objects.
Input was generated by ent.
"""
input NotificationWhereInput {
  not: NotificationWhereInput
  and: [NotificationWhereInput!]
  or: [NotificationWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  title field predicates
  """
  title: String
  titleNEQ: String
  titleIn: [String!]
  titleNotIn: [String!]
  titleGT: String
  titleGTE: String
  titleLT: String
  titleLTE: String
  titleContains: String
  titleHasPrefix: String
  titleHasSuffix: String
  titleEqualFold: String
  titleContainsFold: String
  """
  body field predicates
  """
  body: String
  bodyNEQ: String
  bodyIn: [String!]
  bodyNotIn: [String!]
  bodyGT: String
  bodyGTE: String
  bodyLT: String
  bodyLTE: String
  bodyContains: String
  bodyHasPrefix: String
  bodyHasSuffix: String
  bodyEqualFold: String
  bodyContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  devices(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Devices returned from the connection.
    """
    orderBy: [DeviceOrder!]

    """
    Filtering options for Devices returned from the connection.
    """
    where: DeviceWhereInput
  ): DeviceConnection!
  notifications(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Notifications returned from the connection.
    """
    orderBy: [NotificationOrder!]

    """
    Filtering options for Notifications returned from the connection.
    """
    where: NotificationWhereInput
  ): NotificationConnection!
  roomMembers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
  userContacts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for UserContacts returned from the connection.
    """
    orderBy: [UserContactOrder!]

    """
    Filtering options for UserContacts returned from the connection.
    """
    where: UserContactWhereInput
  ): UserContactConnection!
}
type Room implements Node {
  id: ID!
  name: String
  description: String
  version: Uint64!
  type: RoomType!
  createdAt: Time!
  updatedAt: Time!
  userContacts: [UserContact!]
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
  lastMessage: Message
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  messageVoices(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for MessageVoices returned from the connection.
    """
    orderBy: [MessageVoiceOrder!]

    """
    Filtering options for MessageVoices returned from the connection.
    """
    where: MessageVoiceWhereInput
  ): MessageVoiceConnection!
  messageAttachments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for MessageAttachments returned from the connection.
    """
    orderBy: [MessageAttachmentOrder!]

    """
    Filtering options for MessageAttachments returned from the connection.
    """
    where: MessageAttachmentWhereInput
  ): MessageAttachmentConnection!
  messageLinks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for MessageLinks returned from the connection.
    """
    orderBy: [MessageLinkOrder!]

    """
    Filtering options for MessageLinks returned from the connection.
    """
    where: MessageLinkWhereInput
  ): MessageLinkConnection!
  roomMembers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
}
"""
A connection to a list of items.
"""
type RoomConnection {
  """
  A list of edges.
  """
  edges: [RoomEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type RoomEdge {
  """
  The item at the end of the edge.
  """
  node: Room
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type RoomMember implements Node {
  id: ID!
  name: String
  unreadMessagesCount: Int!
  userID: ID!
  roomID: ID!
  joinedAt: Time!
  updatedAt: Time!
  user: User!
  room: Room!
}
"""
A connection to a list of items.
"""
type RoomMemberConnection {
  """
  A list of edges.
  """
  edges: [RoomMemberEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type RoomMemberEdge {
  """
  The item at the end of the edge.
  """
  node: RoomMember
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for RoomMember connections
"""
input RoomMemberOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order RoomMembers.
  """
  field: RoomMemberOrderField!
}
"""
Properties by which RoomMember connections can be ordered.
"""
enum RoomMemberOrderField {
  NAME
  UNREAD_MESSAGES_COUNT
  JOINED_AT
  UPDATED_AT
  ROOM_UPDATED_AT
}
"""
RoomMemberWhereInput is used for filtering RoomMember objects.
Input was generated by ent.
"""
input RoomMemberWhereInput {
  not: RoomMemberWhereInput
  and: [RoomMemberWhereInput!]
  or: [RoomMemberWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """
  unread_messages_count field predicates
  """
  unreadMessagesCount: Int
  unreadMessagesCountNEQ: Int
  unreadMessagesCountIn: [Int!]
  unreadMessagesCountNotIn: [Int!]
  unreadMessagesCountGT: Int
  unreadMessagesCountGTE: Int
  unreadMessagesCountLT: Int
  unreadMessagesCountLTE: Int
  """
  joined_at field predicates
  """
  joinedAt: Time
  joinedAtNEQ: Time
  joinedAtIn: [Time!]
  joinedAtNotIn: [Time!]
  joinedAtGT: Time
  joinedAtGTE: Time
  joinedAtLT: Time
  joinedAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
}
"""
Ordering options for Room connections
"""
input RoomOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Rooms.
  """
  field: RoomOrderField!
}
"""
Properties by which Room connections can be ordered.
"""
enum RoomOrderField {
  NAME
  DESCRIPTION
  VERSION
  TYPE
  CREATED_AT
  UPDATED_AT
  LAST_MESSAGE_CREATED_AT
}
"""
RoomType is enum for the field type
"""
enum RoomType @goModel(model: "journeyhub/ent/room.Type") {
  Personal
  Group
}
"""
RoomWhereInput is used for filtering Room objects.
Input was generated by ent.
"""
input RoomWhereInput {
  not: RoomWhereInput
  and: [RoomWhereInput!]
  or: [RoomWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """
  description field predicates
  """
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """
  version field predicates
  """
  version: Uint64
  versionNEQ: Uint64
  versionIn: [Uint64!]
  versionNotIn: [Uint64!]
  versionGT: Uint64
  versionGTE: Uint64
  versionLT: Uint64
  versionLTE: Uint64
  """
  type field predicates
  """
  type: RoomType
  typeNEQ: RoomType
  typeIn: [RoomType!]
  typeNotIn: [RoomType!]
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  user_contacts edge predicates
  """
  hasUserContacts: Boolean
  hasUserContactsWith: [UserContactWhereInput!]
  """
  users edge predicates
  """
  hasUsers: Boolean
  hasUsersWith: [UserWhereInput!]
  """
  last_message edge predicates
  """
  hasLastMessage: Boolean
  hasLastMessageWith: [MessageWhereInput!]
  """
  messages edge predicates
  """
  hasMessages: Boolean
  hasMessagesWith: [MessageWhereInput!]
  """
  message_voices edge predicates
  """
  hasMessageVoices: Boolean
  hasMessageVoicesWith: [MessageVoiceWhereInput!]
  """
  message_attachments edge predicates
  """
  hasMessageAttachments: Boolean
  hasMessageAttachmentsWith: [MessageAttachmentWhereInput!]
  """
  message_links edge predicates
  """
  hasMessageLinks: Boolean
  hasMessageLinksWith: [MessageLinkWhereInput!]
  """
  room_members edge predicates
  """
  hasRoomMembers: Boolean
  hasRoomMembersWith: [RoomMemberWhereInput!]
}
"""
The builtin Time type
"""
scalar Time
"""
The builtin Uint type
"""
scalar Uint
"""
The builtin Uint64 type
"""
scalar Uint64
type User implements Node {
  id: ID!
  firstName: String!
  lastName: String!
  nickname: String!
  email: String
  contactPin: String
  createdAt: Time!
  updatedAt: Time!
  device: Device
  notifications(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Notifications returned from the connection.
    """
    orderBy: [NotificationOrder!]

    """
    Filtering options for Notifications returned from the connection.
    """
    where: NotificationWhereInput
  ): NotificationConnection!
  contacts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
  rooms(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Rooms returned from the connection.
    """
    orderBy: [RoomOrder!]

    """
    Filtering options for Rooms returned from the connection.
    """
    where: RoomWhereInput
  ): RoomConnection!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  userContacts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for UserContacts returned from the connection.
    """
    orderBy: [UserContactOrder!]

    """
    Filtering options for UserContacts returned from the connection.
    """
    where: UserContactWhereInput
  ): UserContactConnection!
  memberships(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
}
"""
A connection to a list of items.
"""
type UserConnection {
  """
  A list of edges.
  """
  edges: [UserEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
type UserContact implements Node {
  id: ID!
  userID: ID!
  contactID: ID!
  roomID: ID
  createdAt: Time!
  user: User!
  contact: User!
  room: Room
}
"""
A connection to a list of items.
"""
type UserContactConnection {
  """
  A list of edges.
  """
  edges: [UserContactEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type UserContactEdge {
  """
  The item at the end of the edge.
  """
  node: UserContact
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for UserContact connections
"""
input UserContactOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order UserContacts.
  """
  field: UserContactOrderField!
}
"""
Properties by which UserContact connections can be ordered.
"""
enum UserContactOrderField {
  CREATED_AT
}
"""
UserContactWhereInput is used for filtering UserContact objects.
Input was generated by ent.
"""
input UserContactWhereInput {
  not: UserContactWhereInput
  and: [UserContactWhereInput!]
  or: [UserContactWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
}
"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge.
  """
  node: User
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for User connections
"""
input UserOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Users.
  """
  field: UserOrderField!
}
"""
Properties by which User connections can be ordered.
"""
enum UserOrderField {
  FIRST_NAME
  LAST_NAME
  NICKNAME
  EMAIL
  CREATED_AT
  UPDATED_AT
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  first_name field predicates
  """
  firstName: String
  firstNameNEQ: String
  firstNameIn: [String!]
  firstNameNotIn: [String!]
  firstNameGT: String
  firstNameGTE: String
  firstNameLT: String
  firstNameLTE: String
  firstNameContains: String
  firstNameHasPrefix: String
  firstNameHasSuffix: String
  firstNameEqualFold: String
  firstNameContainsFold: String
  """
  last_name field predicates
  """
  lastName: String
  lastNameNEQ: String
  lastNameIn: [String!]
  lastNameNotIn: [String!]
  lastNameGT: String
  lastNameGTE: String
  lastNameLT: String
  lastNameLTE: String
  lastNameContains: String
  lastNameHasPrefix: String
  lastNameHasSuffix: String
  lastNameEqualFold: String
  lastNameContainsFold: String
  """
  nickname field predicates
  """
  nickname: String
  nicknameNEQ: String
  nicknameIn: [String!]
  nicknameNotIn: [String!]
  nicknameGT: String
  nicknameGTE: String
  nicknameLT: String
  nicknameLTE: String
  nicknameContains: String
  nicknameHasPrefix: String
  nicknameHasSuffix: String
  nicknameEqualFold: String
  nicknameContainsFold: String
  """
  email field predicates
  """
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailIsNil: Boolean
  emailNotNil: Boolean
  emailEqualFold: String
  emailContainsFold: String
  """
  contact_pin field predicates
  """
  contactPin: String
  contactPinNEQ: String
  contactPinIn: [String!]
  contactPinNotIn: [String!]
  contactPinGT: String
  contactPinGTE: String
  contactPinLT: String
  contactPinLTE: String
  contactPinContains: String
  contactPinHasPrefix: String
  contactPinHasSuffix: String
  contactPinIsNil: Boolean
  contactPinNotNil: Boolean
  contactPinEqualFold: String
  contactPinContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  device edge predicates
  """
  hasDevice: Boolean
  hasDeviceWith: [DeviceWhereInput!]
  """
  notifications edge predicates
  """
  hasNotifications: Boolean
  hasNotificationsWith: [NotificationWhereInput!]
  """
  contacts edge predicates
  """
  hasContacts: Boolean
  hasContactsWith: [UserWhereInput!]
  """
  rooms edge predicates
  """
  hasRooms: Boolean
  hasRoomsWith: [RoomWhereInput!]
  """
  messages edge predicates
  """
  hasMessages: Boolean
  hasMessagesWith: [MessageWhereInput!]
  """
  user_contacts edge predicates
  """
  hasUserContacts: Boolean
  hasUserContactsWith: [UserContactWhereInput!]
  """
  memberships edge predicates
  """
  hasMemberships: Boolean
  hasMembershipsWith: [RoomMemberWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/message.graphql", Input: `"""
UploadMessageFile is used for upload message files.
"""
input UploadMessageFileInput {
  type: MessageAttachmentType!
  file: Upload!
}

"""
CreateMessageInput is used for create Message object.
"""
input SendMessageInput {
  roomID: ID!
  notifyUserID: ID
  replyTo: ID
  content: String @goTag(key: "validate", value: "omitempty,max=4096")
  files: [UploadMessageFileInput!] @goTag(key: "validate", value: "max=20")
  voice: Upload @goTag(key: "validate", value: "gql_upload_is_voice")
  links: [CreateMessageLinkInput!]
}

"""
UpdateMessageInput is used for update Message object.
"""
input UpdateMessageInput {
  content: String! @goTag(key: "validate", value: "omitempty,max=4096")
  replaceLinks: [CreateMessageLinkInput!]
}

extend type Query {
  messagesByRoom(
    """
    Returns the elements in the list that come with the specified roomID.
    """
    roomID: ID!

    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
}

extend type Mutation {
  sendMessage(input: SendMessageInput!): MessageEdge
  updateMessage(messageID: ID!, input: UpdateMessageInput!): MessageEdge
  deleteMessage(messageID: ID!): MessageEdge
}

extend type Subscription {
  messageCreated(roomID: ID!): MessageEdge!
  messageUpdated(roomID: ID!): MessageEdge!
  messageDeleted(roomID: ID!): ID!
}
`, BuiltIn: false},
	{Name: "../schema/message_attachment.graphql", Input: `extend type Query {
  messageAttachmentsByRoom(
    """
    Returns the elements in the list that come with the specified roomID.
    """
    roomID: ID!

    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for MessageAttachments returned from the connection.
    """
    orderBy: [MessageAttachmentOrder!]

    """
    Filtering options for MessageAttachments returned from the connection.
    """
    where: MessageAttachmentWhereInput
  ): MessageAttachmentConnection!
}
`, BuiltIn: false},
	{Name: "../schema/message_link.graphql", Input: `"""
CreateMessageLinkInput is used for create message link object.
"""
input CreateMessageLinkInput {
  link: String!
  title: String
  description: String
  imageURL: String
}

extend type Query {
  messageLinksByRoom(
    """
    Returns the elements in the list that come with the specified roomID.
    """
    roomID: ID!

    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for MessageLinks returned from the connection.
    """
    orderBy: [MessageLinkOrder!]

    """
    Filtering options for MessageLinks returned from the connection.
    """
    where: MessageLinkWhereInput
  ): MessageLinkConnection!
}
`, BuiltIn: false},
	{Name: "../schema/message_voice.graphql", Input: `extend type Query {
  messageVoicesByRoom(
    """
    Returns the elements in the list that come with the specified roomID.
    """
    roomID: ID!

    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for MessageVoices returned from the connection.
    """
    orderBy: [MessageVoiceOrder!]

    """
    Filtering options for MessageVoices returned from the connection.
    """
    where: MessageVoiceWhereInput
  ): MessageVoiceConnection!
}
`, BuiltIn: false},
	{Name: "../schema/room.graphql", Input: `"""
CreateRoomInput is used for create Room object.
"""
input CreateRoomInput {
  name: String!
  userIDs: [ID!]
}

"""
UpdateRoomInput is used for update Room object.
"""
input UpdateRoomInput {
  name: String
  addUserIDs: [ID!]
  removeUserIDs: [ID!]
  clearUsers: Boolean
}

extend type Mutation {
  createRoom(input: CreateRoomInput!): RoomEdge
  updateRoom(roomID: ID!, input: UpdateRoomInput!): RoomEdge
  deleteRoom(roomID: ID!): RoomEdge
}

extend type Query {
  room(
    """
    Returns element by the specified roomID.
    """
    roomID: ID!
  ): RoomEdge!
}
`, BuiltIn: false},
	{Name: "../schema/room_member.graphql", Input: `extend input RoomMemberWhereInput {
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
}

extend type Query {
  roomMembersByRoom(
    """
    Returns the elements in the list that come with the specified roomID.
    """
    roomID: ID!

    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
}

extend type Mutation {
  deleteRoomMember(roomMemberID: ID!): RoomMemberEdge
  markRoomMemeberAsSeen(roomMemberID: ID!): RoomMemberEdge
}

type LastMessageUpdatedEvent {
  id: ID!
  content: String!
  createdAt: Time!
  updatedAt: Time!
}

type RoomMemberUpdatedEvent {
  id: ID!
  name: String!
  version: Uint64!
  type: RoomType!
  lastMessage: LastMessageUpdatedEvent
  createdAt: Time!
  updatedAt: Time!
}

extend type Subscription {
  roomMemberCreated: RoomMemberEdge!
  roomMemberUpdated: RoomMemberEdge!
  roomMemberDeleted: ID!
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `"""
The Upload scalar type represents a multipart file upload.
"""
scalar Upload
`, BuiltIn: false},
	{Name: "../schema/user.graphql", Input: `"""
UserRegisterInput is used for user register.
"""
input UserRegisterInput {
  firstName: String! @goTag(key: "validate", value: "min=1,max=255")
  lastName: String! @goTag(key: "validate", value: "min=1,max=255")
  nickname: String! @goTag(key: "validate", value: "min=8,max=255")
  password: String! @goTag(key: "validate", value: "min=8,max=64")
  passwordConfirmation: String! @goTag(key: "validate", value: "min=8,max=64")
}

"""
UserLoginInput is used for user login.
"""
input UserLoginInput {
  nickname: String!
  password: String!
  deviceID: String!
  fcmToken: String!
}

type LoginUser {
  user: User!
  token: String!
}

extend type Mutation {
  register(input: UserRegisterInput!): User
  login(input: UserLoginInput!): LoginUser
}

extend type Query {
  self: User
}
`, BuiltIn: false},
	{Name: "../schema/user_contacts.graphql", Input: `extend input UserContactWhereInput {
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
  """
  contact edge predicates
  """
  hasContact: Boolean
  hasContactWith: [UserWhereInput!]
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
}

extend type Mutation {
  generatePinCode: String
  addUserContact(pincode: String!): UserContactEdge
  deleteUserContact(userContactID: ID!): UserContactEdge
}

extend type Query {
  userContact(
    """
    Returns element by the specified userContactID.
    """
    userContactID: ID!
  ): UserContactEdge!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
