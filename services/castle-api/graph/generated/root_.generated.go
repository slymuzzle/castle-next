// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"journeyhub/ent"
	"journeyhub/ent/schema/pulid"
	"journeyhub/graph/model"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	MessageAttachment() MessageAttachmentResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	MessageAttachmentWhereInput() MessageAttachmentWhereInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	File struct {
		CreatedAt         func(childComplexity int) int
		Disk              func(childComplexity int) int
		ID                func(childComplexity int) int
		MessageAttachment func(childComplexity int) int
		MessageVoice      func(childComplexity int) int
		MimeType          func(childComplexity int) int
		Name              func(childComplexity int) int
		Size              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	Friendship struct {
		CreatedAt func(childComplexity int) int
		Friend    func(childComplexity int) int
		FriendID  func(childComplexity int) int
		ID        func(childComplexity int) int
		Room      func(childComplexity int) int
		RoomID    func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	FriendshipConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	FriendshipEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LoginUser struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	Message struct {
		Attachments func(childComplexity int) int
		Content     func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Links       func(childComplexity int) int
		ReplyTo     func(childComplexity int) int
		Room        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
	}

	MessageAttachment struct {
		AttachedAt func(childComplexity int) int
		File       func(childComplexity int) int
		ID         func(childComplexity int) int
		Message    func(childComplexity int) int
		Order      func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	MessageConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MessageEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	MessageLink struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		URL       func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	MessageVoice struct {
		AttachedAt func(childComplexity int) int
		File       func(childComplexity int) int
		ID         func(childComplexity int) int
		Length     func(childComplexity int) int
	}

	Mutation struct {
		CreateRoom    func(childComplexity int, input model.CreateRoomInput) int
		DeleteMessage func(childComplexity int, messageID pulid.ID) int
		DeleteRoom    func(childComplexity int, roomID pulid.ID) int
		Login         func(childComplexity int, input model.UserLoginInput) int
		Register      func(childComplexity int, input model.UserRegisterInput) int
		SendMessage   func(childComplexity int, input model.SendMessageInput) int
		UpdateMessage func(childComplexity int, messageID pulid.ID, input model.UpdateMessageInput) int
		UpdateRoom    func(childComplexity int, roomID pulid.ID, input model.UpdateRoomInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Friendships func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, where *ent.FriendshipWhereInput) int
		Messages    func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Node        func(childComplexity int, id pulid.ID) int
		Nodes       func(childComplexity int, ids []pulid.ID) int
		RoomMembers func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		Rooms       func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomOrder, where *ent.RoomWhereInput) int
		Self        func(childComplexity int) int
		Users       func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
	}

	Room struct {
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Messages    func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Name        func(childComplexity int) int
		RoomMembers func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Users       func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		Version     func(childComplexity int) int
	}

	RoomConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RoomEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RoomMember struct {
		ID       func(childComplexity int) int
		JoinedAt func(childComplexity int) int
		Room     func(childComplexity int) int
		RoomID   func(childComplexity int) int
		User     func(childComplexity int) int
		UserID   func(childComplexity int) int
	}

	RoomMemberConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RoomMemberEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Subscription struct {
		MessageAdded   func(childComplexity int, roomID pulid.ID) int
		MessageDeleted func(childComplexity int, roomID pulid.ID) int
		MessageUpdated func(childComplexity int, roomID pulid.ID) int
		RoomChanged    func(childComplexity int) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		Email       func(childComplexity int) int
		FirstName   func(childComplexity int) int
		Friends     func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		Friendships func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, where *ent.FriendshipWhereInput) int
		ID          func(childComplexity int) int
		LastName    func(childComplexity int) int
		Memberships func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomMemberOrder, where *ent.RoomMemberWhereInput) int
		Messages    func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Nickname    func(childComplexity int) int
		Rooms       func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.RoomOrder, where *ent.RoomWhereInput) int
		UpdatedAt   func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.disk":
		if e.complexity.File.Disk == nil {
			break
		}

		return e.complexity.File.Disk(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.messageAttachment":
		if e.complexity.File.MessageAttachment == nil {
			break
		}

		return e.complexity.File.MessageAttachment(childComplexity), true

	case "File.messageVoice":
		if e.complexity.File.MessageVoice == nil {
			break
		}

		return e.complexity.File.MessageVoice(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MimeType == nil {
			break
		}

		return e.complexity.File.MimeType(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.updatedAt":
		if e.complexity.File.UpdatedAt == nil {
			break
		}

		return e.complexity.File.UpdatedAt(childComplexity), true

	case "Friendship.createdAt":
		if e.complexity.Friendship.CreatedAt == nil {
			break
		}

		return e.complexity.Friendship.CreatedAt(childComplexity), true

	case "Friendship.friend":
		if e.complexity.Friendship.Friend == nil {
			break
		}

		return e.complexity.Friendship.Friend(childComplexity), true

	case "Friendship.friendID":
		if e.complexity.Friendship.FriendID == nil {
			break
		}

		return e.complexity.Friendship.FriendID(childComplexity), true

	case "Friendship.id":
		if e.complexity.Friendship.ID == nil {
			break
		}

		return e.complexity.Friendship.ID(childComplexity), true

	case "Friendship.room":
		if e.complexity.Friendship.Room == nil {
			break
		}

		return e.complexity.Friendship.Room(childComplexity), true

	case "Friendship.roomID":
		if e.complexity.Friendship.RoomID == nil {
			break
		}

		return e.complexity.Friendship.RoomID(childComplexity), true

	case "Friendship.user":
		if e.complexity.Friendship.User == nil {
			break
		}

		return e.complexity.Friendship.User(childComplexity), true

	case "Friendship.userID":
		if e.complexity.Friendship.UserID == nil {
			break
		}

		return e.complexity.Friendship.UserID(childComplexity), true

	case "FriendshipConnection.edges":
		if e.complexity.FriendshipConnection.Edges == nil {
			break
		}

		return e.complexity.FriendshipConnection.Edges(childComplexity), true

	case "FriendshipConnection.pageInfo":
		if e.complexity.FriendshipConnection.PageInfo == nil {
			break
		}

		return e.complexity.FriendshipConnection.PageInfo(childComplexity), true

	case "FriendshipConnection.totalCount":
		if e.complexity.FriendshipConnection.TotalCount == nil {
			break
		}

		return e.complexity.FriendshipConnection.TotalCount(childComplexity), true

	case "FriendshipEdge.cursor":
		if e.complexity.FriendshipEdge.Cursor == nil {
			break
		}

		return e.complexity.FriendshipEdge.Cursor(childComplexity), true

	case "FriendshipEdge.node":
		if e.complexity.FriendshipEdge.Node == nil {
			break
		}

		return e.complexity.FriendshipEdge.Node(childComplexity), true

	case "LoginUser.token":
		if e.complexity.LoginUser.Token == nil {
			break
		}

		return e.complexity.LoginUser.Token(childComplexity), true

	case "LoginUser.user":
		if e.complexity.LoginUser.User == nil {
			break
		}

		return e.complexity.LoginUser.User(childComplexity), true

	case "Message.attachments":
		if e.complexity.Message.Attachments == nil {
			break
		}

		return e.complexity.Message.Attachments(childComplexity), true

	case "Message.content":
		if e.complexity.Message.Content == nil {
			break
		}

		return e.complexity.Message.Content(childComplexity), true

	case "Message.createdAt":
		if e.complexity.Message.CreatedAt == nil {
			break
		}

		return e.complexity.Message.CreatedAt(childComplexity), true

	case "Message.id":
		if e.complexity.Message.ID == nil {
			break
		}

		return e.complexity.Message.ID(childComplexity), true

	case "Message.links":
		if e.complexity.Message.Links == nil {
			break
		}

		return e.complexity.Message.Links(childComplexity), true

	case "Message.replyTo":
		if e.complexity.Message.ReplyTo == nil {
			break
		}

		return e.complexity.Message.ReplyTo(childComplexity), true

	case "Message.room":
		if e.complexity.Message.Room == nil {
			break
		}

		return e.complexity.Message.Room(childComplexity), true

	case "Message.updatedAt":
		if e.complexity.Message.UpdatedAt == nil {
			break
		}

		return e.complexity.Message.UpdatedAt(childComplexity), true

	case "Message.user":
		if e.complexity.Message.User == nil {
			break
		}

		return e.complexity.Message.User(childComplexity), true

	case "MessageAttachment.attachedAt":
		if e.complexity.MessageAttachment.AttachedAt == nil {
			break
		}

		return e.complexity.MessageAttachment.AttachedAt(childComplexity), true

	case "MessageAttachment.file":
		if e.complexity.MessageAttachment.File == nil {
			break
		}

		return e.complexity.MessageAttachment.File(childComplexity), true

	case "MessageAttachment.id":
		if e.complexity.MessageAttachment.ID == nil {
			break
		}

		return e.complexity.MessageAttachment.ID(childComplexity), true

	case "MessageAttachment.message":
		if e.complexity.MessageAttachment.Message == nil {
			break
		}

		return e.complexity.MessageAttachment.Message(childComplexity), true

	case "MessageAttachment.order":
		if e.complexity.MessageAttachment.Order == nil {
			break
		}

		return e.complexity.MessageAttachment.Order(childComplexity), true

	case "MessageAttachment.type":
		if e.complexity.MessageAttachment.Type == nil {
			break
		}

		return e.complexity.MessageAttachment.Type(childComplexity), true

	case "MessageConnection.edges":
		if e.complexity.MessageConnection.Edges == nil {
			break
		}

		return e.complexity.MessageConnection.Edges(childComplexity), true

	case "MessageConnection.pageInfo":
		if e.complexity.MessageConnection.PageInfo == nil {
			break
		}

		return e.complexity.MessageConnection.PageInfo(childComplexity), true

	case "MessageConnection.totalCount":
		if e.complexity.MessageConnection.TotalCount == nil {
			break
		}

		return e.complexity.MessageConnection.TotalCount(childComplexity), true

	case "MessageEdge.cursor":
		if e.complexity.MessageEdge.Cursor == nil {
			break
		}

		return e.complexity.MessageEdge.Cursor(childComplexity), true

	case "MessageEdge.node":
		if e.complexity.MessageEdge.Node == nil {
			break
		}

		return e.complexity.MessageEdge.Node(childComplexity), true

	case "MessageLink.createdAt":
		if e.complexity.MessageLink.CreatedAt == nil {
			break
		}

		return e.complexity.MessageLink.CreatedAt(childComplexity), true

	case "MessageLink.id":
		if e.complexity.MessageLink.ID == nil {
			break
		}

		return e.complexity.MessageLink.ID(childComplexity), true

	case "MessageLink.message":
		if e.complexity.MessageLink.Message == nil {
			break
		}

		return e.complexity.MessageLink.Message(childComplexity), true

	case "MessageLink.url":
		if e.complexity.MessageLink.URL == nil {
			break
		}

		return e.complexity.MessageLink.URL(childComplexity), true

	case "MessageLink.updatedAt":
		if e.complexity.MessageLink.UpdatedAt == nil {
			break
		}

		return e.complexity.MessageLink.UpdatedAt(childComplexity), true

	case "MessageVoice.attachedAt":
		if e.complexity.MessageVoice.AttachedAt == nil {
			break
		}

		return e.complexity.MessageVoice.AttachedAt(childComplexity), true

	case "MessageVoice.file":
		if e.complexity.MessageVoice.File == nil {
			break
		}

		return e.complexity.MessageVoice.File(childComplexity), true

	case "MessageVoice.id":
		if e.complexity.MessageVoice.ID == nil {
			break
		}

		return e.complexity.MessageVoice.ID(childComplexity), true

	case "MessageVoice.length":
		if e.complexity.MessageVoice.Length == nil {
			break
		}

		return e.complexity.MessageVoice.Length(childComplexity), true

	case "Mutation.createRoom":
		if e.complexity.Mutation.CreateRoom == nil {
			break
		}

		args, err := ec.field_Mutation_createRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRoom(childComplexity, args["input"].(model.CreateRoomInput)), true

	case "Mutation.deleteMessage":
		if e.complexity.Mutation.DeleteMessage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMessage(childComplexity, args["messageID"].(pulid.ID)), true

	case "Mutation.deleteRoom":
		if e.complexity.Mutation.DeleteRoom == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRoom(childComplexity, args["roomID"].(pulid.ID)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.UserLoginInput)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["input"].(model.UserRegisterInput)), true

	case "Mutation.sendMessage":
		if e.complexity.Mutation.SendMessage == nil {
			break
		}

		args, err := ec.field_Mutation_sendMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendMessage(childComplexity, args["input"].(model.SendMessageInput)), true

	case "Mutation.updateMessage":
		if e.complexity.Mutation.UpdateMessage == nil {
			break
		}

		args, err := ec.field_Mutation_updateMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMessage(childComplexity, args["messageID"].(pulid.ID), args["input"].(model.UpdateMessageInput)), true

	case "Mutation.updateRoom":
		if e.complexity.Mutation.UpdateRoom == nil {
			break
		}

		args, err := ec.field_Mutation_updateRoom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRoom(childComplexity, args["roomID"].(pulid.ID), args["input"].(model.UpdateRoomInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.friendships":
		if e.complexity.Query.Friendships == nil {
			break
		}

		args, err := ec.field_Query_friendships_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Friendships(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["where"].(*ent.FriendshipWhereInput)), true

	case "Query.messages":
		if e.complexity.Query.Messages == nil {
			break
		}

		args, err := ec.field_Query_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(pulid.ID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]pulid.ID)), true

	case "Query.roomMembers":
		if e.complexity.Query.RoomMembers == nil {
			break
		}

		args, err := ec.field_Query_roomMembers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RoomMembers(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "Query.rooms":
		if e.complexity.Query.Rooms == nil {
			break
		}

		args, err := ec.field_Query_rooms_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Rooms(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomOrder), args["where"].(*ent.RoomWhereInput)), true

	case "Query.self":
		if e.complexity.Query.Self == nil {
			break
		}

		return e.complexity.Query.Self(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Room.createdAt":
		if e.complexity.Room.CreatedAt == nil {
			break
		}

		return e.complexity.Room.CreatedAt(childComplexity), true

	case "Room.id":
		if e.complexity.Room.ID == nil {
			break
		}

		return e.complexity.Room.ID(childComplexity), true

	case "Room.messages":
		if e.complexity.Room.Messages == nil {
			break
		}

		args, err := ec.field_Room_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "Room.name":
		if e.complexity.Room.Name == nil {
			break
		}

		return e.complexity.Room.Name(childComplexity), true

	case "Room.roomMembers":
		if e.complexity.Room.RoomMembers == nil {
			break
		}

		args, err := ec.field_Room_roomMembers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.RoomMembers(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "Room.type":
		if e.complexity.Room.Type == nil {
			break
		}

		return e.complexity.Room.Type(childComplexity), true

	case "Room.updatedAt":
		if e.complexity.Room.UpdatedAt == nil {
			break
		}

		return e.complexity.Room.UpdatedAt(childComplexity), true

	case "Room.users":
		if e.complexity.Room.Users == nil {
			break
		}

		args, err := ec.field_Room_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.Users(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Room.version":
		if e.complexity.Room.Version == nil {
			break
		}

		return e.complexity.Room.Version(childComplexity), true

	case "RoomConnection.edges":
		if e.complexity.RoomConnection.Edges == nil {
			break
		}

		return e.complexity.RoomConnection.Edges(childComplexity), true

	case "RoomConnection.pageInfo":
		if e.complexity.RoomConnection.PageInfo == nil {
			break
		}

		return e.complexity.RoomConnection.PageInfo(childComplexity), true

	case "RoomConnection.totalCount":
		if e.complexity.RoomConnection.TotalCount == nil {
			break
		}

		return e.complexity.RoomConnection.TotalCount(childComplexity), true

	case "RoomEdge.cursor":
		if e.complexity.RoomEdge.Cursor == nil {
			break
		}

		return e.complexity.RoomEdge.Cursor(childComplexity), true

	case "RoomEdge.node":
		if e.complexity.RoomEdge.Node == nil {
			break
		}

		return e.complexity.RoomEdge.Node(childComplexity), true

	case "RoomMember.id":
		if e.complexity.RoomMember.ID == nil {
			break
		}

		return e.complexity.RoomMember.ID(childComplexity), true

	case "RoomMember.joinedAt":
		if e.complexity.RoomMember.JoinedAt == nil {
			break
		}

		return e.complexity.RoomMember.JoinedAt(childComplexity), true

	case "RoomMember.room":
		if e.complexity.RoomMember.Room == nil {
			break
		}

		return e.complexity.RoomMember.Room(childComplexity), true

	case "RoomMember.roomID":
		if e.complexity.RoomMember.RoomID == nil {
			break
		}

		return e.complexity.RoomMember.RoomID(childComplexity), true

	case "RoomMember.user":
		if e.complexity.RoomMember.User == nil {
			break
		}

		return e.complexity.RoomMember.User(childComplexity), true

	case "RoomMember.userID":
		if e.complexity.RoomMember.UserID == nil {
			break
		}

		return e.complexity.RoomMember.UserID(childComplexity), true

	case "RoomMemberConnection.edges":
		if e.complexity.RoomMemberConnection.Edges == nil {
			break
		}

		return e.complexity.RoomMemberConnection.Edges(childComplexity), true

	case "RoomMemberConnection.pageInfo":
		if e.complexity.RoomMemberConnection.PageInfo == nil {
			break
		}

		return e.complexity.RoomMemberConnection.PageInfo(childComplexity), true

	case "RoomMemberConnection.totalCount":
		if e.complexity.RoomMemberConnection.TotalCount == nil {
			break
		}

		return e.complexity.RoomMemberConnection.TotalCount(childComplexity), true

	case "RoomMemberEdge.cursor":
		if e.complexity.RoomMemberEdge.Cursor == nil {
			break
		}

		return e.complexity.RoomMemberEdge.Cursor(childComplexity), true

	case "RoomMemberEdge.node":
		if e.complexity.RoomMemberEdge.Node == nil {
			break
		}

		return e.complexity.RoomMemberEdge.Node(childComplexity), true

	case "Subscription.messageAdded":
		if e.complexity.Subscription.MessageAdded == nil {
			break
		}

		args, err := ec.field_Subscription_messageAdded_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.MessageAdded(childComplexity, args["roomID"].(pulid.ID)), true

	case "Subscription.messageDeleted":
		if e.complexity.Subscription.MessageDeleted == nil {
			break
		}

		args, err := ec.field_Subscription_messageDeleted_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.MessageDeleted(childComplexity, args["roomID"].(pulid.ID)), true

	case "Subscription.messageUpdated":
		if e.complexity.Subscription.MessageUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_messageUpdated_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.MessageUpdated(childComplexity, args["roomID"].(pulid.ID)), true

	case "Subscription.roomChanged":
		if e.complexity.Subscription.RoomChanged == nil {
			break
		}

		return e.complexity.Subscription.RoomChanged(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.firstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.friends":
		if e.complexity.User.Friends == nil {
			break
		}

		args, err := ec.field_User_friends_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Friends(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "User.friendships":
		if e.complexity.User.Friendships == nil {
			break
		}

		args, err := ec.field_User_friendships_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Friendships(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["where"].(*ent.FriendshipWhereInput)), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.memberships":
		if e.complexity.User.Memberships == nil {
			break
		}

		args, err := ec.field_User_memberships_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Memberships(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomMemberOrder), args["where"].(*ent.RoomMemberWhereInput)), true

	case "User.messages":
		if e.complexity.User.Messages == nil {
			break
		}

		args, err := ec.field_User_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "User.nickname":
		if e.complexity.User.Nickname == nil {
			break
		}

		return e.complexity.User.Nickname(childComplexity), true

	case "User.rooms":
		if e.complexity.User.Rooms == nil {
			break
		}

		args, err := ec.field_User_rooms_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Rooms(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.RoomOrder), args["where"].(*ent.RoomWhereInput)), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateRoomInput,
		ec.unmarshalInputFileOrder,
		ec.unmarshalInputFileWhereInput,
		ec.unmarshalInputFriendshipWhereInput,
		ec.unmarshalInputMessageAttachmentOrder,
		ec.unmarshalInputMessageAttachmentWhereInput,
		ec.unmarshalInputMessageLinkOrder,
		ec.unmarshalInputMessageLinkWhereInput,
		ec.unmarshalInputMessageOrder,
		ec.unmarshalInputMessageVoiceOrder,
		ec.unmarshalInputMessageVoiceWhereInput,
		ec.unmarshalInputMessageWhereInput,
		ec.unmarshalInputRoomMemberOrder,
		ec.unmarshalInputRoomMemberWhereInput,
		ec.unmarshalInputRoomOrder,
		ec.unmarshalInputRoomWhereInput,
		ec.unmarshalInputSendMessageInput,
		ec.unmarshalInputUpdateMessageInput,
		ec.unmarshalInputUpdateRoomInput,
		ec.unmarshalInputUserLoginInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserRegisterInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphql", Input: `directive @goTag(
  key: String!
  value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type File implements Node {
  id: ID!
  name: String!
  mimeType: String!
  disk: String!
  size: Uint64!
  createdAt: Time!
  updatedAt: Time!
  messageAttachment: MessageAttachment
  messageVoice: MessageVoice
}
"""
Ordering options for File connections
"""
input FileOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Files.
  """
  field: FileOrderField!
}
"""
Properties by which File connections can be ordered.
"""
enum FileOrderField {
  NAME
  MIME_TYPE
  DISK
  SIZE
  CREATED_AT
  UPDATED_AT
}
"""
FileWhereInput is used for filtering File objects.
Input was generated by ent.
"""
input FileWhereInput {
  not: FileWhereInput
  and: [FileWhereInput!]
  or: [FileWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  mime_type field predicates
  """
  mimeType: String
  mimeTypeNEQ: String
  mimeTypeIn: [String!]
  mimeTypeNotIn: [String!]
  mimeTypeGT: String
  mimeTypeGTE: String
  mimeTypeLT: String
  mimeTypeLTE: String
  mimeTypeContains: String
  mimeTypeHasPrefix: String
  mimeTypeHasSuffix: String
  mimeTypeEqualFold: String
  mimeTypeContainsFold: String
  """
  disk field predicates
  """
  disk: String
  diskNEQ: String
  diskIn: [String!]
  diskNotIn: [String!]
  diskGT: String
  diskGTE: String
  diskLT: String
  diskLTE: String
  diskContains: String
  diskHasPrefix: String
  diskHasSuffix: String
  diskEqualFold: String
  diskContainsFold: String
  """
  size field predicates
  """
  size: Uint64
  sizeNEQ: Uint64
  sizeIn: [Uint64!]
  sizeNotIn: [Uint64!]
  sizeGT: Uint64
  sizeGTE: Uint64
  sizeLT: Uint64
  sizeLTE: Uint64
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  message_attachment edge predicates
  """
  hasMessageAttachment: Boolean
  hasMessageAttachmentWith: [MessageAttachmentWhereInput!]
  """
  message_voice edge predicates
  """
  hasMessageVoice: Boolean
  hasMessageVoiceWith: [MessageVoiceWhereInput!]
}
type Friendship implements Node {
  id: ID!
  userID: ID!
  friendID: ID!
  roomID: ID
  createdAt: Time!
  user: User!
  friend: User!
  room: Room
}
"""
A connection to a list of items.
"""
type FriendshipConnection {
  """
  A list of edges.
  """
  edges: [FriendshipEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type FriendshipEdge {
  """
  The item at the end of the edge.
  """
  node: Friendship
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
FriendshipWhereInput is used for filtering Friendship objects.
Input was generated by ent.
"""
input FriendshipWhereInput {
  not: FriendshipWhereInput
  and: [FriendshipWhereInput!]
  or: [FriendshipWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
}
type Message implements Node {
  id: ID!
  content: String!
  createdAt: Time!
  updatedAt: Time!
  user: User
  room: Room
  replyTo: Message
  attachments: [MessageAttachment!]
  links: [MessageLink!]
}
type MessageAttachment implements Node {
  id: ID!
  type: MessageAttachmentType!
  order: Uint!
  attachedAt: Time!
  message: Message!
  file: File!
}
"""
Ordering options for MessageAttachment connections
"""
input MessageAttachmentOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order MessageAttachments.
  """
  field: MessageAttachmentOrderField!
}
"""
Properties by which MessageAttachment connections can be ordered.
"""
enum MessageAttachmentOrderField {
  TYPE
  ORDER
  ATTACHED_AT
}
"""
MessageAttachmentType is enum for the field type
"""
enum MessageAttachmentType @goModel(model: "journeyhub/ent/messageattachment.Type") {
  Image
  Video
  Document
}
"""
MessageAttachmentWhereInput is used for filtering MessageAttachment objects.
Input was generated by ent.
"""
input MessageAttachmentWhereInput {
  not: MessageAttachmentWhereInput
  and: [MessageAttachmentWhereInput!]
  or: [MessageAttachmentWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  type field predicates
  """
  type: MessageAttachmentType
  typeNEQ: MessageAttachmentType
  typeIn: [MessageAttachmentType!]
  typeNotIn: [MessageAttachmentType!]
  """
  order field predicates
  """
  order: Uint
  orderNEQ: Uint
  orderIn: [Uint!]
  orderNotIn: [Uint!]
  orderGT: Uint
  orderGTE: Uint
  orderLT: Uint
  orderLTE: Uint
  """
  attached_at field predicates
  """
  attachedAt: Time
  attachedAtNEQ: Time
  attachedAtIn: [Time!]
  attachedAtNotIn: [Time!]
  attachedAtGT: Time
  attachedAtGTE: Time
  attachedAtLT: Time
  attachedAtLTE: Time
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
  """
  file edge predicates
  """
  hasFile: Boolean
  hasFileWith: [FileWhereInput!]
}
"""
A connection to a list of items.
"""
type MessageConnection {
  """
  A list of edges.
  """
  edges: [MessageEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type MessageEdge {
  """
  The item at the end of the edge.
  """
  node: Message
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type MessageLink implements Node {
  id: ID!
  url: String!
  createdAt: Time!
  updatedAt: Time!
  message: Message!
}
"""
Ordering options for MessageLink connections
"""
input MessageLinkOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order MessageLinks.
  """
  field: MessageLinkOrderField!
}
"""
Properties by which MessageLink connections can be ordered.
"""
enum MessageLinkOrderField {
  URL
  CREATED_AT
  UPDATED_AT
}
"""
MessageLinkWhereInput is used for filtering MessageLink objects.
Input was generated by ent.
"""
input MessageLinkWhereInput {
  not: MessageLinkWhereInput
  and: [MessageLinkWhereInput!]
  or: [MessageLinkWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  url field predicates
  """
  url: String
  urlNEQ: String
  urlIn: [String!]
  urlNotIn: [String!]
  urlGT: String
  urlGTE: String
  urlLT: String
  urlLTE: String
  urlContains: String
  urlHasPrefix: String
  urlHasSuffix: String
  urlEqualFold: String
  urlContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
}
"""
Ordering options for Message connections
"""
input MessageOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Messages.
  """
  field: MessageOrderField!
}
"""
Properties by which Message connections can be ordered.
"""
enum MessageOrderField {
  CREATED_AT
  UPDATED_AT
}
type MessageVoice implements Node {
  id: ID!
  length: Int!
  attachedAt: Time!
  file: File!
}
"""
Ordering options for MessageVoice connections
"""
input MessageVoiceOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order MessageVoices.
  """
  field: MessageVoiceOrderField!
}
"""
Properties by which MessageVoice connections can be ordered.
"""
enum MessageVoiceOrderField {
  LENGTH
  ATTACHED_AT
}
"""
MessageVoiceWhereInput is used for filtering MessageVoice objects.
Input was generated by ent.
"""
input MessageVoiceWhereInput {
  not: MessageVoiceWhereInput
  and: [MessageVoiceWhereInput!]
  or: [MessageVoiceWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  length field predicates
  """
  length: Int
  lengthNEQ: Int
  lengthIn: [Int!]
  lengthNotIn: [Int!]
  lengthGT: Int
  lengthGTE: Int
  lengthLT: Int
  lengthLTE: Int
  """
  attached_at field predicates
  """
  attachedAt: Time
  attachedAtNEQ: Time
  attachedAtIn: [Time!]
  attachedAtNotIn: [Time!]
  attachedAtGT: Time
  attachedAtGTE: Time
  attachedAtLT: Time
  attachedAtLTE: Time
  """
  file edge predicates
  """
  hasFile: Boolean
  hasFileWith: [FileWhereInput!]
}
"""
MessageWhereInput is used for filtering Message objects.
Input was generated by ent.
"""
input MessageWhereInput {
  not: MessageWhereInput
  and: [MessageWhereInput!]
  or: [MessageWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  content field predicates
  """
  content: String
  contentNEQ: String
  contentIn: [String!]
  contentNotIn: [String!]
  contentGT: String
  contentGTE: String
  contentLT: String
  contentLTE: String
  contentContains: String
  contentHasPrefix: String
  contentHasSuffix: String
  contentEqualFold: String
  contentContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
  """
  room edge predicates
  """
  hasRoom: Boolean
  hasRoomWith: [RoomWhereInput!]
  """
  reply_to edge predicates
  """
  hasReplyTo: Boolean
  hasReplyToWith: [MessageWhereInput!]
  """
  attachments edge predicates
  """
  hasAttachments: Boolean
  hasAttachmentsWith: [MessageAttachmentWhereInput!]
  """
  links edge predicates
  """
  hasLinks: Boolean
  hasLinksWith: [MessageLinkWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "journeyhub/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  friendships(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Friendships returned from the connection.
    """
    where: FriendshipWhereInput
  ): FriendshipConnection!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  rooms(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Rooms returned from the connection.
    """
    orderBy: [RoomOrder!]

    """
    Filtering options for Rooms returned from the connection.
    """
    where: RoomWhereInput
  ): RoomConnection!
  roomMembers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
}
type Room implements Node {
  id: ID!
  name: String!
  version: Uint64!
  type: RoomType!
  createdAt: Time!
  updatedAt: Time!
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  roomMembers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
}
"""
A connection to a list of items.
"""
type RoomConnection {
  """
  A list of edges.
  """
  edges: [RoomEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type RoomEdge {
  """
  The item at the end of the edge.
  """
  node: Room
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type RoomMember implements Node {
  id: ID!
  userID: ID!
  roomID: ID!
  joinedAt: Time!
  user: User!
  room: Room!
}
"""
A connection to a list of items.
"""
type RoomMemberConnection {
  """
  A list of edges.
  """
  edges: [RoomMemberEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type RoomMemberEdge {
  """
  The item at the end of the edge.
  """
  node: RoomMember
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for RoomMember connections
"""
input RoomMemberOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order RoomMembers.
  """
  field: RoomMemberOrderField!
}
"""
Properties by which RoomMember connections can be ordered.
"""
enum RoomMemberOrderField {
  JOINED_AT
}
"""
RoomMemberWhereInput is used for filtering RoomMember objects.
Input was generated by ent.
"""
input RoomMemberWhereInput {
  not: RoomMemberWhereInput
  and: [RoomMemberWhereInput!]
  or: [RoomMemberWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  joined_at field predicates
  """
  joinedAt: Time
  joinedAtNEQ: Time
  joinedAtIn: [Time!]
  joinedAtNotIn: [Time!]
  joinedAtGT: Time
  joinedAtGTE: Time
  joinedAtLT: Time
  joinedAtLTE: Time
}
"""
Ordering options for Room connections
"""
input RoomOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Rooms.
  """
  field: RoomOrderField!
}
"""
Properties by which Room connections can be ordered.
"""
enum RoomOrderField {
  NAME
  VERSION
  TYPE
  CREATED_AT
  UPDATED_AT
}
"""
RoomType is enum for the field type
"""
enum RoomType @goModel(model: "journeyhub/ent/room.Type") {
  Personal
  Group
}
"""
RoomWhereInput is used for filtering Room objects.
Input was generated by ent.
"""
input RoomWhereInput {
  not: RoomWhereInput
  and: [RoomWhereInput!]
  or: [RoomWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  version field predicates
  """
  version: Uint64
  versionNEQ: Uint64
  versionIn: [Uint64!]
  versionNotIn: [Uint64!]
  versionGT: Uint64
  versionGTE: Uint64
  versionLT: Uint64
  versionLTE: Uint64
  """
  type field predicates
  """
  type: RoomType
  typeNEQ: RoomType
  typeIn: [RoomType!]
  typeNotIn: [RoomType!]
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  users edge predicates
  """
  hasUsers: Boolean
  hasUsersWith: [UserWhereInput!]
  """
  messages edge predicates
  """
  hasMessages: Boolean
  hasMessagesWith: [MessageWhereInput!]
  """
  room_members edge predicates
  """
  hasRoomMembers: Boolean
  hasRoomMembersWith: [RoomMemberWhereInput!]
}
"""
The builtin Time type
"""
scalar Time
"""
The builtin Uint type
"""
scalar Uint
"""
The builtin Uint64 type
"""
scalar Uint64
type User implements Node {
  id: ID!
  firstName: String!
  lastName: String!
  nickname: String!
  email: String!
  createdAt: Time!
  updatedAt: Time!
  friends(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
  rooms(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Rooms returned from the connection.
    """
    orderBy: [RoomOrder!]

    """
    Filtering options for Rooms returned from the connection.
    """
    where: RoomWhereInput
  ): RoomConnection!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  friendships(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Friendships returned from the connection.
    """
    where: FriendshipWhereInput
  ): FriendshipConnection!
  memberships(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for RoomMembers returned from the connection.
    """
    orderBy: [RoomMemberOrder!]

    """
    Filtering options for RoomMembers returned from the connection.
    """
    where: RoomMemberWhereInput
  ): RoomMemberConnection!
}
"""
A connection to a list of items.
"""
type UserConnection {
  """
  A list of edges.
  """
  edges: [UserEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge.
  """
  node: User
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for User connections
"""
input UserOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Users.
  """
  field: UserOrderField!
}
"""
Properties by which User connections can be ordered.
"""
enum UserOrderField {
  FIRST_NAME
  LAST_NAME
  NICKNAME
  EMAIL
  CREATED_AT
  UPDATED_AT
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  first_name field predicates
  """
  firstName: String
  firstNameNEQ: String
  firstNameIn: [String!]
  firstNameNotIn: [String!]
  firstNameGT: String
  firstNameGTE: String
  firstNameLT: String
  firstNameLTE: String
  firstNameContains: String
  firstNameHasPrefix: String
  firstNameHasSuffix: String
  firstNameEqualFold: String
  firstNameContainsFold: String
  """
  last_name field predicates
  """
  lastName: String
  lastNameNEQ: String
  lastNameIn: [String!]
  lastNameNotIn: [String!]
  lastNameGT: String
  lastNameGTE: String
  lastNameLT: String
  lastNameLTE: String
  lastNameContains: String
  lastNameHasPrefix: String
  lastNameHasSuffix: String
  lastNameEqualFold: String
  lastNameContainsFold: String
  """
  nickname field predicates
  """
  nickname: String
  nicknameNEQ: String
  nicknameIn: [String!]
  nicknameNotIn: [String!]
  nicknameGT: String
  nicknameGTE: String
  nicknameLT: String
  nicknameLTE: String
  nicknameContains: String
  nicknameHasPrefix: String
  nicknameHasSuffix: String
  nicknameEqualFold: String
  nicknameContainsFold: String
  """
  email field predicates
  """
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  friends edge predicates
  """
  hasFriends: Boolean
  hasFriendsWith: [UserWhereInput!]
  """
  rooms edge predicates
  """
  hasRooms: Boolean
  hasRoomsWith: [RoomWhereInput!]
  """
  messages edge predicates
  """
  hasMessages: Boolean
  hasMessagesWith: [MessageWhereInput!]
  """
  friendships edge predicates
  """
  hasFriendships: Boolean
  hasFriendshipsWith: [FriendshipWhereInput!]
  """
  memberships edge predicates
  """
  hasMemberships: Boolean
  hasMembershipsWith: [RoomMemberWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/message.graphql", Input: `"""
The Upload scalar type represents a multipart file upload.
"""
scalar Upload

"""
CreateMessageInput is used for create Message object.
"""
input SendMessageInput {
  targetUserID: ID!
  replyTo: ID
  content: String!
}

"""
UpdateMessageInput is used for update Message object.
"""
input UpdateMessageInput {
  content: String!
}

extend type Mutation {
  sendMessage(input: SendMessageInput!): Message
  updateMessage(messageID: ID!, input: UpdateMessageInput!): Message
  deleteMessage(messageID: ID!): Message
}

extend type Subscription {
  messageAdded(roomID: ID!): Message!
  messageUpdated(roomID: ID!): Message!
  messageDeleted(roomID: ID!): Message!
}
`, BuiltIn: false},
	{Name: "../schema/room.graphql", Input: `"""
CreateRoomInput is used for create Room object.
"""
input CreateRoomInput {
  name: String!
  userIDs: [ID!]
}

"""
UpdateRoomInput is used for update Room object.
"""
input UpdateRoomInput {
  name: String
  addUserIDs: [ID!]
  removeUserIDs: [ID!]
  clearUsers: Boolean
}

extend type Mutation {
  createRoom(input: CreateRoomInput!): Room
  updateRoom(roomID: ID!, input: UpdateRoomInput!): Room
  deleteRoom(roomID: ID!): Room
}

extend type Subscription {
  roomChanged: Message!
}
`, BuiltIn: false},
	{Name: "../schema/user.graphql", Input: `"""
UserRegisterInput is used for user register.
"""
input UserRegisterInput {
  firstName: String! @goTag(key: "validate", value: "min=1,max=255")
  lastName: String! @goTag(key: "validate", value: "min=1,max=255")
  email: String! @goTag(key: "validate", value: "min=1,max=255,email")
  nickname: String! @goTag(key: "validate", value: "min=8,max=255")
  password: String! @goTag(key: "validate", value: "min=8,max=64")
  passwordConfirmation: String! @goTag(key: "validate", value: "min=8,max=64")
}

"""
UserLoginInput is used for user login.
"""
input UserLoginInput {
  nicknameOrEmail: String!
  password: String!
}

type LoginUser {
  user: User!
  token: String!
}

extend type Mutation {
  register(input: UserRegisterInput!): User
  login(input: UserLoginInput!): LoginUser
}

extend type Query {
  self: User
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
